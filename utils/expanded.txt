#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
pub mod types {
    pub mod database_types {
        use alohomora::TahiniType;
        use alohomora::bbox::BBox;
        use alohomora::rocket::RequestBBoxJson;
        use alohomora::tarpc::traits::TahiniError;
        use alohomora::tarpc::{TahiniEnum, TahiniType};
        use serde::{Deserialize, Serialize};
        use crate::policies::PromptPolicy;
        use crate::policies::shared_policies::UsernamePolicy;
        use crate::types::inference_types::Message;
        pub struct DatabaseStoreForm {
            pub uuid: BBox<String, UsernamePolicy>,
            pub conv_id: BBox<Option<String>, UsernamePolicy>,
            pub message: BBox<Message, PromptPolicy>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseStoreForm {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "uuid" => _serde::__private::Ok(__Field::__field0),
                                "conv_id" => _serde::__private::Ok(__Field::__field1),
                                "message" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"uuid" => _serde::__private::Ok(__Field::__field0),
                                b"conv_id" => _serde::__private::Ok(__Field::__field1),
                                b"message" => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseStoreForm>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseStoreForm;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseStoreForm",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                BBox<String, UsernamePolicy>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseStoreForm with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                BBox<Option<String>, UsernamePolicy>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseStoreForm with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                BBox<Message, PromptPolicy>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct DatabaseStoreForm with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseStoreForm {
                                uuid: __field0,
                                conv_id: __field1,
                                message: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                BBox<String, UsernamePolicy>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                BBox<Option<String>, UsernamePolicy>,
                            > = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                BBox<Message, PromptPolicy>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("uuid"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBox<String, UsernamePolicy>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "conv_id",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBox<Option<String>, UsernamePolicy>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "message",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBox<Message, PromptPolicy>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("uuid")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("conv_id")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("message")?
                                }
                            };
                            _serde::__private::Ok(DatabaseStoreForm {
                                uuid: __field0,
                                conv_id: __field1,
                                message: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "uuid",
                        "conv_id",
                        "message",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseStoreForm",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseStoreForm>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseStoreForm {
            #[inline]
            fn clone(&self) -> DatabaseStoreForm {
                DatabaseStoreForm {
                    uuid: ::core::clone::Clone::clone(&self.uuid),
                    conv_id: ::core::clone::Clone::clone(&self.conv_id),
                    message: ::core::clone::Clone::clone(&self.message),
                }
            }
        }
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for DatabaseStoreForm {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                let mut map: ::std::collections::HashMap<
                    &'static str,
                    ::alohomora::tarpc::TahiniEnum,
                > = ::std::collections::HashMap::from([
                    (
                        "uuid",
                        <BBox<
                            String,
                            UsernamePolicy,
                        > as TahiniType>::to_tahini_enum(&self.uuid),
                    ),
                    (
                        "conv_id",
                        <BBox<
                            Option<String>,
                            UsernamePolicy,
                        > as TahiniType>::to_tahini_enum(&self.conv_id),
                    ),
                    (
                        "message",
                        <BBox<
                            Message,
                            PromptPolicy,
                        > as TahiniType>::to_tahini_enum(&self.message),
                    ),
                ]);
                ::alohomora::tarpc::TahiniEnum::Struct("DatabaseStoreForm", map)
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                let mut policy_vec = Vec::new();
                policy_vec
                    .push(self.uuid.tahini_policy_check(members_fmt, context, reason));
                policy_vec
                    .push(
                        self.conv_id.tahini_policy_check(members_fmt, context, reason),
                    );
                policy_vec
                    .push(
                        self.message.tahini_policy_check(members_fmt, context, reason),
                    );
                policy_vec.iter().all(|x: &bool| *x)
            }
        }
        pub struct DatabaseRetrieveForm {
            pub uuid: BBox<String, UsernamePolicy>,
            pub conv_id: CHATUID,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseRetrieveForm {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "uuid" => _serde::__private::Ok(__Field::__field0),
                                "conv_id" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"uuid" => _serde::__private::Ok(__Field::__field0),
                                b"conv_id" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseRetrieveForm>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseRetrieveForm;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct DatabaseRetrieveForm",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                BBox<String, UsernamePolicy>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct DatabaseRetrieveForm with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                CHATUID,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct DatabaseRetrieveForm with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(DatabaseRetrieveForm {
                                uuid: __field0,
                                conv_id: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                BBox<String, UsernamePolicy>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<CHATUID> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("uuid"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBox<String, UsernamePolicy>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "conv_id",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<CHATUID>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("uuid")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("conv_id")?
                                }
                            };
                            _serde::__private::Ok(DatabaseRetrieveForm {
                                uuid: __field0,
                                conv_id: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["uuid", "conv_id"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DatabaseRetrieveForm",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DatabaseRetrieveForm,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseRetrieveForm {
            #[inline]
            fn clone(&self) -> DatabaseRetrieveForm {
                DatabaseRetrieveForm {
                    uuid: ::core::clone::Clone::clone(&self.uuid),
                    conv_id: ::core::clone::Clone::clone(&self.conv_id),
                }
            }
        }
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for DatabaseRetrieveForm {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                let mut map: ::std::collections::HashMap<
                    &'static str,
                    ::alohomora::tarpc::TahiniEnum,
                > = ::std::collections::HashMap::from([
                    (
                        "uuid",
                        <BBox<
                            String,
                            UsernamePolicy,
                        > as TahiniType>::to_tahini_enum(&self.uuid),
                    ),
                    ("conv_id", <CHATUID as TahiniType>::to_tahini_enum(&self.conv_id)),
                ]);
                ::alohomora::tarpc::TahiniEnum::Struct("DatabaseRetrieveForm", map)
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                let mut policy_vec = Vec::new();
                policy_vec
                    .push(self.uuid.tahini_policy_check(members_fmt, context, reason));
                policy_vec
                    .push(
                        self.conv_id.tahini_policy_check(members_fmt, context, reason),
                    );
                policy_vec.iter().all(|x: &bool| *x)
            }
        }
        impl ::alohomora::rocket::RequestBBoxJson for DatabaseRetrieveForm {
            fn from_json(
                mut __value: ::alohomora::rocket::InputBBoxValue,
                __request: ::alohomora::rocket::BBoxRequest<'_, '_>,
            ) -> Result<Self, &'static str> {
                Ok(Self {
                    uuid: __value.get("uuid")?.into_json(__request)?,
                    conv_id: __value.get("conv_id")?.into_json(__request)?,
                })
            }
        }
        pub type CHATUID = BBox<String, UsernamePolicy>;
        pub type DatabaseRecord = DatabaseStoreForm;
        pub enum DatabaseError {
            UserNotFound,
            AlreadyExists,
            InternalError,
            Ambiguous,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseError {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        DatabaseError::UserNotFound => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DatabaseError",
                                0u32,
                                "UserNotFound",
                            )
                        }
                        DatabaseError::AlreadyExists => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DatabaseError",
                                1u32,
                                "AlreadyExists",
                            )
                        }
                        DatabaseError::InternalError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DatabaseError",
                                2u32,
                                "InternalError",
                            )
                        }
                        DatabaseError::Ambiguous => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "DatabaseError",
                                3u32,
                                "Ambiguous",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseError {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 4",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "UserNotFound" => _serde::__private::Ok(__Field::__field0),
                                "AlreadyExists" => _serde::__private::Ok(__Field::__field1),
                                "InternalError" => _serde::__private::Ok(__Field::__field2),
                                "Ambiguous" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"UserNotFound" => _serde::__private::Ok(__Field::__field0),
                                b"AlreadyExists" => _serde::__private::Ok(__Field::__field1),
                                b"InternalError" => _serde::__private::Ok(__Field::__field2),
                                b"Ambiguous" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseError>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseError;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DatabaseError",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(DatabaseError::UserNotFound)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(DatabaseError::AlreadyExists)
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(DatabaseError::InternalError)
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(DatabaseError::Ambiguous)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "UserNotFound",
                        "AlreadyExists",
                        "InternalError",
                        "Ambiguous",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DatabaseError",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseError>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for DatabaseError {
            #[inline]
            fn clone(&self) -> DatabaseError {
                match self {
                    DatabaseError::UserNotFound => DatabaseError::UserNotFound,
                    DatabaseError::AlreadyExists => DatabaseError::AlreadyExists,
                    DatabaseError::InternalError => DatabaseError::InternalError,
                    DatabaseError::Ambiguous => DatabaseError::Ambiguous,
                }
            }
        }
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for DatabaseError {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    DatabaseError::UserNotFound => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseError",
                            0u32,
                            "UserNotFound",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::Unit,
                        )
                    }
                    DatabaseError::AlreadyExists => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseError",
                            1u32,
                            "AlreadyExists",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::Unit,
                        )
                    }
                    DatabaseError::InternalError => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseError",
                            2u32,
                            "InternalError",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::Unit,
                        )
                    }
                    DatabaseError::Ambiguous => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseError",
                            3u32,
                            "Ambiguous",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::Unit,
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    DatabaseError::UserNotFound => true,
                    DatabaseError::AlreadyExists => true,
                    DatabaseError::InternalError => true,
                    DatabaseError::Ambiguous => true,
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for DatabaseError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        DatabaseError::UserNotFound => "UserNotFound",
                        DatabaseError::AlreadyExists => "AlreadyExists",
                        DatabaseError::InternalError => "InternalError",
                        DatabaseError::Ambiguous => "Ambiguous",
                    },
                )
            }
        }
        impl std::error::Error for DatabaseError {}
        impl std::fmt::Display for DatabaseError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let string = match self {
                    DatabaseError::UserNotFound => "User not found in the database",
                    DatabaseError::AlreadyExists => "User already exists in the database",
                    DatabaseError::InternalError => "Internal Error",
                    DatabaseError::Ambiguous => {
                        "Multiple entries found when one was expected"
                    }
                };
                f.write_fmt(format_args!("{0}", string))
            }
        }
        impl alohomora::tarpc::traits::TahiniError for DatabaseError {}
    }
    pub mod inference_types {
        use alohomora::bbox::BBox;
        use alohomora::rocket::{RequestBBoxJson, ResponseBBoxJson};
        use alohomora::tarpc::{TahiniEnum, TahiniType};
        use alohomora::{AlohomoraType, TahiniType};
        use std::collections::HashMap;
        use tarpc::serde::{Deserialize, Serialize};
        use crate::policies::PromptPolicy;
        pub struct UserPrompt {
            pub conversation: BBoxConversation,
            pub nb_token: u32,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UserPrompt {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "conversation" => _serde::__private::Ok(__Field::__field0),
                                "nb_token" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"conversation" => _serde::__private::Ok(__Field::__field0),
                                b"nb_token" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UserPrompt>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UserPrompt;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UserPrompt",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                BBoxConversation,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UserPrompt with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                u32,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UserPrompt with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UserPrompt {
                                conversation: __field0,
                                nb_token: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                BBoxConversation,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "conversation",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBoxConversation,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "nb_token",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<u32>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("conversation")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("nb_token")?
                                }
                            };
                            _serde::__private::Ok(UserPrompt {
                                conversation: __field0,
                                nb_token: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "conversation",
                        "nb_token",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UserPrompt",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UserPrompt>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for UserPrompt {
            #[inline]
            fn clone(&self) -> UserPrompt {
                UserPrompt {
                    conversation: ::core::clone::Clone::clone(&self.conversation),
                    nb_token: ::core::clone::Clone::clone(&self.nb_token),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UserPrompt {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "UserPrompt",
                    "conversation",
                    &self.conversation,
                    "nb_token",
                    &&self.nb_token,
                )
            }
        }
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for UserPrompt {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                let mut map: ::std::collections::HashMap<
                    &'static str,
                    ::alohomora::tarpc::TahiniEnum,
                > = ::std::collections::HashMap::from([
                    (
                        "conversation",
                        <BBoxConversation as TahiniType>::to_tahini_enum(
                            &self.conversation,
                        ),
                    ),
                    ("nb_token", <u32 as TahiniType>::to_tahini_enum(&self.nb_token)),
                ]);
                ::alohomora::tarpc::TahiniEnum::Struct("UserPrompt", map)
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                let mut policy_vec = Vec::new();
                policy_vec
                    .push(
                        self
                            .conversation
                            .tahini_policy_check(members_fmt, context, reason),
                    );
                policy_vec
                    .push(
                        self.nb_token.tahini_policy_check(members_fmt, context, reason),
                    );
                policy_vec.iter().all(|x: &bool| *x)
            }
        }
        pub struct LLMResponse {
            pub infered_tokens: BBox<Result<Message, LLMError>, PromptPolicy>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for LLMResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "infered_tokens" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"infered_tokens" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<LLMResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = LLMResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct LLMResponse",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                BBox<Result<Message, LLMError>, PromptPolicy>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct LLMResponse with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(LLMResponse {
                                infered_tokens: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                BBox<Result<Message, LLMError>, PromptPolicy>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "infered_tokens",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBox<Result<Message, LLMError>, PromptPolicy>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("infered_tokens")?
                                }
                            };
                            _serde::__private::Ok(LLMResponse {
                                infered_tokens: __field0,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["infered_tokens"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "LLMResponse",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<LLMResponse>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for LLMResponse {
            #[inline]
            fn clone(&self) -> LLMResponse {
                LLMResponse {
                    infered_tokens: ::core::clone::Clone::clone(&self.infered_tokens),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LLMResponse {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "LLMResponse",
                    "infered_tokens",
                    &&self.infered_tokens,
                )
            }
        }
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for LLMResponse {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                let mut map: ::std::collections::HashMap<
                    &'static str,
                    ::alohomora::tarpc::TahiniEnum,
                > = ::std::collections::HashMap::from([
                    (
                        "infered_tokens",
                        <BBox<
                            Result<Message, LLMError>,
                            PromptPolicy,
                        > as TahiniType>::to_tahini_enum(&self.infered_tokens),
                    ),
                ]);
                ::alohomora::tarpc::TahiniEnum::Struct("LLMResponse", map)
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                let mut policy_vec = Vec::new();
                policy_vec
                    .push(
                        self
                            .infered_tokens
                            .tahini_policy_check(members_fmt, context, reason),
                    );
                policy_vec.iter().all(|x: &bool| *x)
            }
        }
        pub type BBoxConversation = BBox<Vec<Message>, PromptPolicy>;
        pub struct Message {
            pub role: String,
            pub content: String,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Message {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "Message",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "role",
                        &self.role,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "content",
                        &self.content,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        impl ::alohomora::rocket::RequestBBoxJson for Message {
            fn from_json(
                mut __value: ::alohomora::rocket::InputBBoxValue,
                __request: ::alohomora::rocket::BBoxRequest<'_, '_>,
            ) -> Result<Self, &'static str> {
                Ok(Self {
                    role: __value.get("role")?.into_json(__request)?,
                    content: __value.get("content")?.into_json(__request)?,
                })
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Message {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "role" => _serde::__private::Ok(__Field::__field0),
                                "content" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"role" => _serde::__private::Ok(__Field::__field0),
                                b"content" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Message>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Message;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Message",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Message with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Message with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Message {
                                role: __field0,
                                content: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("role"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "content",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("role")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("content")?
                                }
                            };
                            _serde::__private::Ok(Message {
                                role: __field0,
                                content: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["role", "content"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Message",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Message>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for Message {
            #[inline]
            fn clone(&self) -> Message {
                Message {
                    role: ::core::clone::Clone::clone(&self.role),
                    content: ::core::clone::Clone::clone(&self.content),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Message {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Message",
                    "role",
                    &self.role,
                    "content",
                    &&self.content,
                )
            }
        }
        impl ::alohomora::rocket::ResponseBBoxJson for Message {
            fn to_json(self) -> ::alohomora::rocket::OutputBBoxValue {
                ::alohomora::rocket::OutputBBoxValue::Object(
                    HashMap::from([
                        (String::from("role"), self.role.to_json()),
                        (String::from("content"), self.content.to_json()),
                    ]),
                )
            }
        }
        pub enum LLMError {
            InternalError,
            ValidationError,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for LLMError {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(
                    f,
                    match self {
                        LLMError::InternalError => "InternalError",
                        LLMError::ValidationError => "ValidationError",
                    },
                )
            }
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for LLMError {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 2",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "InternalError" => _serde::__private::Ok(__Field::__field0),
                                "ValidationError" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"InternalError" => _serde::__private::Ok(__Field::__field0),
                                b"ValidationError" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<LLMError>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = LLMError;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum LLMError",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LLMError::InternalError)
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::de::VariantAccess::unit_variant(__variant)?;
                                    _serde::__private::Ok(LLMError::ValidationError)
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "InternalError",
                        "ValidationError",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "LLMError",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<LLMError>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for LLMError {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        LLMError::InternalError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LLMError",
                                0u32,
                                "InternalError",
                            )
                        }
                        LLMError::ValidationError => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "LLMError",
                                1u32,
                                "ValidationError",
                            )
                        }
                    }
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for LLMError {
            #[inline]
            fn clone(&self) -> LLMError {
                match self {
                    LLMError::InternalError => LLMError::InternalError,
                    LLMError::ValidationError => LLMError::ValidationError,
                }
            }
        }
        impl std::fmt::Display for LLMError {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.write_fmt(format_args!("Internal LLM Error"))
            }
        }
        impl std::error::Error for LLMError {}
        impl alohomora::tarpc::traits::TahiniError for LLMError {}
    }
    pub mod marketing_types {
        use crate::policies::MarketingPolicy;
        use alohomora::bbox::BBox;
        use alohomora::tarpc::{TahiniEnum, TahiniType};
        use alohomora::{AlohomoraType, TahiniType};
        use tarpc::serde::{Deserialize, Serialize};
        pub struct MarketingData {
            pub username: Option<String>,
            pub prompt: String,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MarketingData {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "MarketingData",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "username",
                        &self.username,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "prompt",
                        &self.prompt,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MarketingData {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "username" => _serde::__private::Ok(__Field::__field0),
                                "prompt" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"username" => _serde::__private::Ok(__Field::__field0),
                                b"prompt" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MarketingData>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MarketingData;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MarketingData",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MarketingData with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                String,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MarketingData with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MarketingData {
                                username: __field0,
                                prompt: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                Option<String>,
                            > = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<String> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "username",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                Option<String>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("prompt"),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<String>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("username")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("prompt")?
                                }
                            };
                            _serde::__private::Ok(MarketingData {
                                username: __field0,
                                prompt: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["username", "prompt"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MarketingData",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MarketingData>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for MarketingData {
            #[inline]
            fn clone(&self) -> MarketingData {
                MarketingData {
                    username: ::core::clone::Clone::clone(&self.username),
                    prompt: ::core::clone::Clone::clone(&self.prompt),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MarketingData {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "MarketingData",
                    "username",
                    &self.username,
                    "prompt",
                    &&self.prompt,
                )
            }
        }
        pub struct Ad {
            pub ad: BBox<String, MarketingPolicy>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Ad {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "ad" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"ad" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Ad>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Ad;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct Ad",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                BBox<String, MarketingPolicy>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Ad with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Ad { ad: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<
                                BBox<String, MarketingPolicy>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field("ad"),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                BBox<String, MarketingPolicy>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("ad")?
                                }
                            };
                            _serde::__private::Ok(Ad { ad: __field0 })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &["ad"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Ad",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Ad>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for Ad {
            #[inline]
            fn clone(&self) -> Ad {
                Ad {
                    ad: ::core::clone::Clone::clone(&self.ad),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Ad {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field1_finish(
                    f,
                    "Ad",
                    "ad",
                    &&self.ad,
                )
            }
        }
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for Ad {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                let mut map: ::std::collections::HashMap<
                    &'static str,
                    ::alohomora::tarpc::TahiniEnum,
                > = ::std::collections::HashMap::from([
                    (
                        "ad",
                        <BBox<
                            String,
                            MarketingPolicy,
                        > as TahiniType>::to_tahini_enum(&self.ad),
                    ),
                ]);
                ::alohomora::tarpc::TahiniEnum::Struct("Ad", map)
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                let mut policy_vec = Vec::new();
                policy_vec
                    .push(self.ad.tahini_policy_check(members_fmt, context, reason));
                policy_vec.iter().all(|x: &bool| *x)
            }
        }
    }
    use alohomora::tarpc::traits::TahiniError;
    use serde::{Deserialize, Serialize};
    pub struct PolicyError;
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for PolicyError {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serializer::serialize_unit_struct(__serializer, "PolicyError")
            }
        }
    };
    #[doc(hidden)]
    #[allow(
        non_upper_case_globals,
        unused_attributes,
        unused_qualifications,
        clippy::absolute_paths,
    )]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for PolicyError {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[doc(hidden)]
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<PolicyError>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                #[automatically_derived]
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = PolicyError;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "unit struct PolicyError",
                        )
                    }
                    #[inline]
                    fn visit_unit<__E>(
                        self,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        _serde::__private::Ok(PolicyError)
                    }
                }
                _serde::Deserializer::deserialize_unit_struct(
                    __deserializer,
                    "PolicyError",
                    __Visitor {
                        marker: _serde::__private::PhantomData::<PolicyError>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    impl ::core::fmt::Debug for PolicyError {
        #[inline]
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "PolicyError")
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for PolicyError {
        #[inline]
        fn clone(&self) -> PolicyError {
            PolicyError
        }
    }
    impl std::fmt::Display for PolicyError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("Failed policy check"))
        }
    }
    impl std::error::Error for PolicyError {}
    impl TahiniError for PolicyError {}
}
pub mod rpc {
    pub mod inference {
        use crate::types::inference_types::{LLMResponse, UserPrompt};
        use alohomora::tarpc::{client::TahiniStub, TahiniType};
        use alohomora::tahini_service;
        pub trait Inference: ::core::marker::Sized + Clone {
            async fn inference(
                self,
                context: ::tarpc::context::Context,
                prompt: UserPrompt,
            ) -> LLMResponse;
            /// Returns a serving function to use with
            /// [InFlightRequest::execute](::tarpc::server::InFlightRequest::execute).
            fn serve(self) -> ServeInference<Self> {
                ServeInference { service: self }
            }
        }
        /// A serving function to use with [::tarpc::server::InFlightRequest::execute].
        pub struct ServeInference<S> {
            service: S,
        }
        #[automatically_derived]
        impl<S: ::core::clone::Clone> ::core::clone::Clone for ServeInference<S> {
            #[inline]
            fn clone(&self) -> ServeInference<S> {
                ServeInference {
                    service: ::core::clone::Clone::clone(&self.service),
                }
            }
        }
        impl<S> ::alohomora::tarpc::server::TahiniServe for ServeInference<S>
        where
            S: Inference + Clone,
        {
            type Req = InferenceTahiniRequest;
            type Resp = InferenceTahiniResponse;
            async fn serve(
                self,
                ctx: ::tarpc::context::Context,
                req: InferenceTahiniRequest,
            ) -> ::core::result::Result<InferenceTahiniResponse, ::tarpc::ServerError> {
                match req {
                    InferenceTahiniRequest::Inference { prompt } => {
                        ::core::result::Result::Ok(
                            InferenceTahiniResponse::Inference(
                                Inference::inference(self.service, ctx, prompt).await,
                            ),
                        )
                    }
                }
            }
        }
        /// The request sent over the wire from the client to the server.
        #[allow(missing_docs)]
        pub enum InferenceTahiniRequest {
            Inference { prompt: UserPrompt },
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for InferenceTahiniRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Inference" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Inference" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<InferenceTahiniRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = InferenceTahiniRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum InferenceTahiniRequest",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "prompt" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"prompt" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            InferenceTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = InferenceTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant InferenceTahiniRequest::Inference",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                UserPrompt,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant InferenceTahiniRequest::Inference with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(InferenceTahiniRequest::Inference {
                                                prompt: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<UserPrompt> = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("prompt"),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<UserPrompt>(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("prompt")?
                                                }
                                            };
                                            _serde::__private::Ok(InferenceTahiniRequest::Inference {
                                                prompt: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["prompt"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                InferenceTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Inference"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "InferenceTahiniRequest",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                InferenceTahiniRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for InferenceTahiniRequest {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    InferenceTahiniRequest::Inference { prompt } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "InferenceTahiniRequest",
                            0u32,
                            "Inference",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "prompt",
                                            <UserPrompt as TahiniType>::to_tahini_enum(prompt),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    InferenceTahiniRequest::Inference { prompt } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                prompt.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for InferenceTahiniRequest {
            #[inline]
            fn clone(&self) -> InferenceTahiniRequest {
                match self {
                    InferenceTahiniRequest::Inference { prompt: __self_0 } => {
                        InferenceTahiniRequest::Inference {
                            prompt: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        /// The response sent over the wire from the server to the client.
        #[allow(missing_docs)]
        pub enum InferenceTahiniResponse {
            Inference(LLMResponse),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for InferenceTahiniResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Inference" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Inference" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<InferenceTahiniResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = InferenceTahiniResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum InferenceTahiniResponse",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            LLMResponse,
                                        >(__variant),
                                        InferenceTahiniResponse::Inference,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["Inference"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "InferenceTahiniResponse",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                InferenceTahiniResponse,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for InferenceTahiniResponse {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    InferenceTahiniResponse::Inference(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "InferenceTahiniResponse",
                            0u32,
                            "Inference",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    InferenceTahiniResponse::Inference(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for InferenceTahiniResponse {
            #[inline]
            fn clone(&self) -> InferenceTahiniResponse {
                match self {
                    InferenceTahiniResponse::Inference(__self_0) => {
                        InferenceTahiniResponse::Inference(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[allow(unused)]
        /// The client stub that makes RPC calls to the server. All request methods return
        /// [Futures](::core::future::Future).
        pub struct TahiniInferenceClient(
            ::alohomora::tarpc::client::TahiniChannel<
                InferenceTahiniRequest,
                InferenceTahiniResponse,
            >,
        );
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::clone::Clone for TahiniInferenceClient {
            #[inline]
            fn clone(&self) -> TahiniInferenceClient {
                TahiniInferenceClient(::core::clone::Clone::clone(&self.0))
            }
        }
        impl TahiniInferenceClient {
            /// Returns a new client stub that sends requests over the given transport.
            pub fn new<T>(
                config: ::tarpc::client::Config,
                transport: T,
            ) -> ::alohomora::tarpc::client::TahiniNewClient<
                Self,
                ::alohomora::tarpc::client::TahiniRequestDispatch<
                    InferenceTahiniRequest,
                    InferenceTahiniResponse,
                    T,
                >,
            >
            where
                T: ::tarpc::Transport<
                    ::tarpc::ClientMessage<
                        ::alohomora::tarpc::enums::TahiniSafeWrapper<
                            InferenceTahiniRequest,
                        >,
                    >,
                    ::tarpc::Response<InferenceTahiniResponse>,
                >,
            {
                let new_client = ::alohomora::tarpc::client::new(config, transport);
                ::alohomora::tarpc::client::TahiniNewClient {
                    client: TahiniInferenceClient(new_client.client),
                    dispatch: new_client.dispatch,
                }
            }
            #[allow(unused)]
            pub fn inference(
                &self,
                ctx: ::tarpc::context::Context,
                prompt: UserPrompt,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<LLMResponse, ::tarpc::client::RpcError>,
            > + '_ {
                let request = InferenceTahiniRequest::Inference {
                    prompt,
                };
                let resp = self.0.call(ctx, "InferenceTahiniRequest.Inference", request);
                async move {
                    match resp.await? {
                        InferenceTahiniResponse::Inference(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
        }
    }
    pub mod database {
        use crate::{
            policies::{ConversationMetadataPolicy, shared_policies::UsernamePolicy},
            types::{
                PolicyError,
                database_types::{
                    CHATUID, DatabaseError, DatabaseRecord, DatabaseRetrieveForm,
                    DatabaseStoreForm,
                },
                inference_types::BBoxConversation,
            },
        };
        use alohomora::{
            bbox::BBox, tahini_service, tarpc::{client::TahiniStub, TahiniType},
        };
        pub trait Database: ::core::marker::Sized + Clone {
            async fn store_prompt(
                self,
                context: ::tarpc::context::Context,
                prompt: DatabaseStoreForm,
            ) -> Result<CHATUID, PolicyError>;
            async fn retrieve_prompt(
                self,
                context: ::tarpc::context::Context,
                retrieve: DatabaseRetrieveForm,
            ) -> Option<BBoxConversation>;
            async fn fetch_user(
                self,
                context: ::tarpc::context::Context,
                username: BBox<String, UsernamePolicy>,
            ) -> Result<BBox<String, UsernamePolicy>, DatabaseError>;
            async fn register_user(
                self,
                context: ::tarpc::context::Context,
                username: BBox<String, UsernamePolicy>,
            ) -> Result<BBox<String, UsernamePolicy>, DatabaseError>;
            async fn fetch_history_headers(
                self,
                context: ::tarpc::context::Context,
                username: BBox<String, UsernamePolicy>,
            ) -> Vec<BBox<String, ConversationMetadataPolicy>>;
            async fn get_default_user(
                self,
                context: ::tarpc::context::Context,
            ) -> BBox<String, UsernamePolicy>;
            async fn delete_conversation(
                self,
                context: ::tarpc::context::Context,
                user_id: BBox<String, UsernamePolicy>,
                conv_id: BBox<String, ConversationMetadataPolicy>,
            ) -> bool;
            /// Returns a serving function to use with
            /// [InFlightRequest::execute](::tarpc::server::InFlightRequest::execute).
            fn serve(self) -> ServeDatabase<Self> {
                ServeDatabase { service: self }
            }
        }
        /// A serving function to use with [::tarpc::server::InFlightRequest::execute].
        pub struct ServeDatabase<S> {
            service: S,
        }
        #[automatically_derived]
        impl<S: ::core::clone::Clone> ::core::clone::Clone for ServeDatabase<S> {
            #[inline]
            fn clone(&self) -> ServeDatabase<S> {
                ServeDatabase {
                    service: ::core::clone::Clone::clone(&self.service),
                }
            }
        }
        impl<S> ::alohomora::tarpc::server::TahiniServe for ServeDatabase<S>
        where
            S: Database + Clone,
        {
            type Req = DatabaseTahiniRequest;
            type Resp = DatabaseTahiniResponse;
            async fn serve(
                self,
                ctx: ::tarpc::context::Context,
                req: DatabaseTahiniRequest,
            ) -> ::core::result::Result<DatabaseTahiniResponse, ::tarpc::ServerError> {
                match req {
                    DatabaseTahiniRequest::StorePrompt { prompt } => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::StorePrompt(
                                Database::store_prompt(self.service, ctx, prompt).await,
                            ),
                        )
                    }
                    DatabaseTahiniRequest::RetrievePrompt { retrieve } => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::RetrievePrompt(
                                Database::retrieve_prompt(self.service, ctx, retrieve).await,
                            ),
                        )
                    }
                    DatabaseTahiniRequest::FetchUser { username } => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::FetchUser(
                                Database::fetch_user(self.service, ctx, username).await,
                            ),
                        )
                    }
                    DatabaseTahiniRequest::RegisterUser { username } => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::RegisterUser(
                                Database::register_user(self.service, ctx, username).await,
                            ),
                        )
                    }
                    DatabaseTahiniRequest::FetchHistoryHeaders { username } => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::FetchHistoryHeaders(
                                Database::fetch_history_headers(self.service, ctx, username)
                                    .await,
                            ),
                        )
                    }
                    DatabaseTahiniRequest::GetDefaultUser {} => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::GetDefaultUser(
                                Database::get_default_user(self.service, ctx).await,
                            ),
                        )
                    }
                    DatabaseTahiniRequest::DeleteConversation { user_id, conv_id } => {
                        ::core::result::Result::Ok(
                            DatabaseTahiniResponse::DeleteConversation(
                                Database::delete_conversation(
                                        self.service,
                                        ctx,
                                        user_id,
                                        conv_id,
                                    )
                                    .await,
                            ),
                        )
                    }
                }
            }
        }
        /// The request sent over the wire from the client to the server.
        #[allow(missing_docs)]
        pub enum DatabaseTahiniRequest {
            StorePrompt { prompt: DatabaseStoreForm },
            RetrievePrompt { retrieve: DatabaseRetrieveForm },
            FetchUser { username: BBox<String, UsernamePolicy> },
            RegisterUser { username: BBox<String, UsernamePolicy> },
            FetchHistoryHeaders { username: BBox<String, UsernamePolicy> },
            GetDefaultUser {},
            DeleteConversation {
                user_id: BBox<String, UsernamePolicy>,
                conv_id: BBox<String, ConversationMetadataPolicy>,
            },
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseTahiniRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 7",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "StorePrompt" => _serde::__private::Ok(__Field::__field0),
                                "RetrievePrompt" => _serde::__private::Ok(__Field::__field1),
                                "FetchUser" => _serde::__private::Ok(__Field::__field2),
                                "RegisterUser" => _serde::__private::Ok(__Field::__field3),
                                "FetchHistoryHeaders" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "GetDefaultUser" => _serde::__private::Ok(__Field::__field5),
                                "DeleteConversation" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"StorePrompt" => _serde::__private::Ok(__Field::__field0),
                                b"RetrievePrompt" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"FetchUser" => _serde::__private::Ok(__Field::__field2),
                                b"RegisterUser" => _serde::__private::Ok(__Field::__field3),
                                b"FetchHistoryHeaders" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"GetDefaultUser" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"DeleteConversation" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseTahiniRequest>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseTahiniRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DatabaseTahiniRequest",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "prompt" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"prompt" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::StorePrompt",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                DatabaseStoreForm,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant DatabaseTahiniRequest::StorePrompt with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::StorePrompt {
                                                prompt: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                DatabaseStoreForm,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("prompt"),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                DatabaseStoreForm,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("prompt")?
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::StorePrompt {
                                                prompt: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["prompt"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "retrieve" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"retrieve" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::RetrievePrompt",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                DatabaseRetrieveForm,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant DatabaseTahiniRequest::RetrievePrompt with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::RetrievePrompt {
                                                retrieve: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                DatabaseRetrieveForm,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                                    "retrieve",
                                                                ),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                DatabaseRetrieveForm,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("retrieve")?
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::RetrievePrompt {
                                                retrieve: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["retrieve"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "username" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"username" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::FetchUser",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                BBox<String, UsernamePolicy>,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant DatabaseTahiniRequest::FetchUser with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::FetchUser {
                                                username: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                BBox<String, UsernamePolicy>,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                                    "username",
                                                                ),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                BBox<String, UsernamePolicy>,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("username")?
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::FetchUser {
                                                username: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["username"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "username" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"username" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::RegisterUser",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                BBox<String, UsernamePolicy>,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant DatabaseTahiniRequest::RegisterUser with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::RegisterUser {
                                                username: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                BBox<String, UsernamePolicy>,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                                    "username",
                                                                ),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                BBox<String, UsernamePolicy>,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("username")?
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::RegisterUser {
                                                username: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["username"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "username" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"username" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::FetchHistoryHeaders",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                BBox<String, UsernamePolicy>,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant DatabaseTahiniRequest::FetchHistoryHeaders with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::FetchHistoryHeaders {
                                                username: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                BBox<String, UsernamePolicy>,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                                    "username",
                                                                ),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                BBox<String, UsernamePolicy>,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("username")?
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::FetchHistoryHeaders {
                                                username: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["username"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::GetDefaultUser",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            _: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            _serde::__private::Ok(DatabaseTahiniRequest::GetDefaultUser {})
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            _serde::__private::Ok(DatabaseTahiniRequest::GetDefaultUser {})
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &[];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __field1,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                1u64 => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "user_id" => _serde::__private::Ok(__Field::__field0),
                                                "conv_id" => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"user_id" => _serde::__private::Ok(__Field::__field0),
                                                b"conv_id" => _serde::__private::Ok(__Field::__field1),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            DatabaseTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = DatabaseTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant DatabaseTahiniRequest::DeleteConversation",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                BBox<String, UsernamePolicy>,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant DatabaseTahiniRequest::DeleteConversation with 2 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                                BBox<String, ConversationMetadataPolicy>,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            1usize,
                                                            &"struct variant DatabaseTahiniRequest::DeleteConversation with 2 elements",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::DeleteConversation {
                                                user_id: __field0,
                                                conv_id: __field1,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                BBox<String, UsernamePolicy>,
                                            > = _serde::__private::None;
                                            let mut __field1: _serde::__private::Option<
                                                BBox<String, ConversationMetadataPolicy>,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                                    "user_id",
                                                                ),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                BBox<String, UsernamePolicy>,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    __Field::__field1 => {
                                                        if _serde::__private::Option::is_some(&__field1) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                                    "conv_id",
                                                                ),
                                                            );
                                                        }
                                                        __field1 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                BBox<String, ConversationMetadataPolicy>,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("user_id")?
                                                }
                                            };
                                            let __field1 = match __field1 {
                                                _serde::__private::Some(__field1) => __field1,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("conv_id")?
                                                }
                                            };
                                            _serde::__private::Ok(DatabaseTahiniRequest::DeleteConversation {
                                                user_id: __field0,
                                                conv_id: __field1,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &[
                                        "user_id",
                                        "conv_id",
                                    ];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                DatabaseTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "StorePrompt",
                        "RetrievePrompt",
                        "FetchUser",
                        "RegisterUser",
                        "FetchHistoryHeaders",
                        "GetDefaultUser",
                        "DeleteConversation",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DatabaseTahiniRequest",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DatabaseTahiniRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for DatabaseTahiniRequest {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    DatabaseTahiniRequest::StorePrompt { prompt } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            0u32,
                            "StorePrompt",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "prompt",
                                            <DatabaseStoreForm as TahiniType>::to_tahini_enum(prompt),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                    DatabaseTahiniRequest::RetrievePrompt { retrieve } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            1u32,
                            "RetrievePrompt",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "retrieve",
                                            <DatabaseRetrieveForm as TahiniType>::to_tahini_enum(
                                                retrieve,
                                            ),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                    DatabaseTahiniRequest::FetchUser { username } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            2u32,
                            "FetchUser",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "username",
                                            <BBox<
                                                String,
                                                UsernamePolicy,
                                            > as TahiniType>::to_tahini_enum(username),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                    DatabaseTahiniRequest::RegisterUser { username } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            3u32,
                            "RegisterUser",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "username",
                                            <BBox<
                                                String,
                                                UsernamePolicy,
                                            > as TahiniType>::to_tahini_enum(username),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                    DatabaseTahiniRequest::FetchHistoryHeaders { username } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            4u32,
                            "FetchHistoryHeaders",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "username",
                                            <BBox<
                                                String,
                                                UsernamePolicy,
                                            > as TahiniType>::to_tahini_enum(username),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                    DatabaseTahiniRequest::GetDefaultUser {} => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            5u32,
                            "GetDefaultUser",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([]),
                                )
                            },
                        )
                    }
                    DatabaseTahiniRequest::DeleteConversation { user_id, conv_id } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniRequest",
                            6u32,
                            "DeleteConversation",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "user_id",
                                            <BBox<
                                                String,
                                                UsernamePolicy,
                                            > as TahiniType>::to_tahini_enum(user_id),
                                        ),
                                        (
                                            "conv_id",
                                            <BBox<
                                                String,
                                                ConversationMetadataPolicy,
                                            > as TahiniType>::to_tahini_enum(conv_id),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    DatabaseTahiniRequest::StorePrompt { prompt } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                prompt.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                    DatabaseTahiniRequest::RetrievePrompt { retrieve } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                retrieve.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                    DatabaseTahiniRequest::FetchUser { username } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                username.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                    DatabaseTahiniRequest::RegisterUser { username } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                username.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                    DatabaseTahiniRequest::FetchHistoryHeaders { username } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                username.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                    DatabaseTahiniRequest::GetDefaultUser {} => {
                        let mut policy_vec = Vec::new();
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                    DatabaseTahiniRequest::DeleteConversation { user_id, conv_id } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                user_id.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec
                            .push(
                                conv_id.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for DatabaseTahiniRequest {
            #[inline]
            fn clone(&self) -> DatabaseTahiniRequest {
                match self {
                    DatabaseTahiniRequest::StorePrompt { prompt: __self_0 } => {
                        DatabaseTahiniRequest::StorePrompt {
                            prompt: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    DatabaseTahiniRequest::RetrievePrompt { retrieve: __self_0 } => {
                        DatabaseTahiniRequest::RetrievePrompt {
                            retrieve: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    DatabaseTahiniRequest::FetchUser { username: __self_0 } => {
                        DatabaseTahiniRequest::FetchUser {
                            username: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    DatabaseTahiniRequest::RegisterUser { username: __self_0 } => {
                        DatabaseTahiniRequest::RegisterUser {
                            username: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    DatabaseTahiniRequest::FetchHistoryHeaders { username: __self_0 } => {
                        DatabaseTahiniRequest::FetchHistoryHeaders {
                            username: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                    DatabaseTahiniRequest::GetDefaultUser {} => {
                        DatabaseTahiniRequest::GetDefaultUser {
                        }
                    }
                    DatabaseTahiniRequest::DeleteConversation {
                        user_id: __self_0,
                        conv_id: __self_1,
                    } => {
                        DatabaseTahiniRequest::DeleteConversation {
                            user_id: ::core::clone::Clone::clone(__self_0),
                            conv_id: ::core::clone::Clone::clone(__self_1),
                        }
                    }
                }
            }
        }
        /// The response sent over the wire from the server to the client.
        #[allow(missing_docs)]
        pub enum DatabaseTahiniResponse {
            StorePrompt(Result<CHATUID, PolicyError>),
            RetrievePrompt(Option<BBoxConversation>),
            FetchUser(Result<BBox<String, UsernamePolicy>, DatabaseError>),
            RegisterUser(Result<BBox<String, UsernamePolicy>, DatabaseError>),
            FetchHistoryHeaders(Vec<BBox<String, ConversationMetadataPolicy>>),
            GetDefaultUser(BBox<String, UsernamePolicy>),
            DeleteConversation(bool),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseTahiniResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                5u64 => _serde::__private::Ok(__Field::__field5),
                                6u64 => _serde::__private::Ok(__Field::__field6),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 7",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "StorePrompt" => _serde::__private::Ok(__Field::__field0),
                                "RetrievePrompt" => _serde::__private::Ok(__Field::__field1),
                                "FetchUser" => _serde::__private::Ok(__Field::__field2),
                                "RegisterUser" => _serde::__private::Ok(__Field::__field3),
                                "FetchHistoryHeaders" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                "GetDefaultUser" => _serde::__private::Ok(__Field::__field5),
                                "DeleteConversation" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"StorePrompt" => _serde::__private::Ok(__Field::__field0),
                                b"RetrievePrompt" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"FetchUser" => _serde::__private::Ok(__Field::__field2),
                                b"RegisterUser" => _serde::__private::Ok(__Field::__field3),
                                b"FetchHistoryHeaders" => {
                                    _serde::__private::Ok(__Field::__field4)
                                }
                                b"GetDefaultUser" => {
                                    _serde::__private::Ok(__Field::__field5)
                                }
                                b"DeleteConversation" => {
                                    _serde::__private::Ok(__Field::__field6)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseTahiniResponse>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseTahiniResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DatabaseTahiniResponse",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Result<CHATUID, PolicyError>,
                                        >(__variant),
                                        DatabaseTahiniResponse::StorePrompt,
                                    )
                                }
                                (__Field::__field1, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Option<BBoxConversation>,
                                        >(__variant),
                                        DatabaseTahiniResponse::RetrievePrompt,
                                    )
                                }
                                (__Field::__field2, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Result<BBox<String, UsernamePolicy>, DatabaseError>,
                                        >(__variant),
                                        DatabaseTahiniResponse::FetchUser,
                                    )
                                }
                                (__Field::__field3, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Result<BBox<String, UsernamePolicy>, DatabaseError>,
                                        >(__variant),
                                        DatabaseTahiniResponse::RegisterUser,
                                    )
                                }
                                (__Field::__field4, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            Vec<BBox<String, ConversationMetadataPolicy>>,
                                        >(__variant),
                                        DatabaseTahiniResponse::FetchHistoryHeaders,
                                    )
                                }
                                (__Field::__field5, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            BBox<String, UsernamePolicy>,
                                        >(__variant),
                                        DatabaseTahiniResponse::GetDefaultUser,
                                    )
                                }
                                (__Field::__field6, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<
                                            bool,
                                        >(__variant),
                                        DatabaseTahiniResponse::DeleteConversation,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &[
                        "StorePrompt",
                        "RetrievePrompt",
                        "FetchUser",
                        "RegisterUser",
                        "FetchHistoryHeaders",
                        "GetDefaultUser",
                        "DeleteConversation",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DatabaseTahiniResponse",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                DatabaseTahiniResponse,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for DatabaseTahiniResponse {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    DatabaseTahiniResponse::StorePrompt(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            0u32,
                            "StorePrompt",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                    DatabaseTahiniResponse::RetrievePrompt(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            1u32,
                            "RetrievePrompt",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                    DatabaseTahiniResponse::FetchUser(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            2u32,
                            "FetchUser",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                    DatabaseTahiniResponse::RegisterUser(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            3u32,
                            "RegisterUser",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                    DatabaseTahiniResponse::FetchHistoryHeaders(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            4u32,
                            "FetchHistoryHeaders",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                    DatabaseTahiniResponse::GetDefaultUser(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            5u32,
                            "GetDefaultUser",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                    DatabaseTahiniResponse::DeleteConversation(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "DatabaseTahiniResponse",
                            6u32,
                            "DeleteConversation",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    DatabaseTahiniResponse::StorePrompt(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                    DatabaseTahiniResponse::RetrievePrompt(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                    DatabaseTahiniResponse::FetchUser(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                    DatabaseTahiniResponse::RegisterUser(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                    DatabaseTahiniResponse::FetchHistoryHeaders(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                    DatabaseTahiniResponse::GetDefaultUser(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                    DatabaseTahiniResponse::DeleteConversation(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for DatabaseTahiniResponse {
            #[inline]
            fn clone(&self) -> DatabaseTahiniResponse {
                match self {
                    DatabaseTahiniResponse::StorePrompt(__self_0) => {
                        DatabaseTahiniResponse::StorePrompt(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseTahiniResponse::RetrievePrompt(__self_0) => {
                        DatabaseTahiniResponse::RetrievePrompt(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseTahiniResponse::FetchUser(__self_0) => {
                        DatabaseTahiniResponse::FetchUser(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseTahiniResponse::RegisterUser(__self_0) => {
                        DatabaseTahiniResponse::RegisterUser(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseTahiniResponse::FetchHistoryHeaders(__self_0) => {
                        DatabaseTahiniResponse::FetchHistoryHeaders(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseTahiniResponse::GetDefaultUser(__self_0) => {
                        DatabaseTahiniResponse::GetDefaultUser(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    DatabaseTahiniResponse::DeleteConversation(__self_0) => {
                        DatabaseTahiniResponse::DeleteConversation(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[allow(unused)]
        /// The client stub that makes RPC calls to the server. All request methods return
        /// [Futures](::core::future::Future).
        pub struct TahiniDatabaseClient(
            ::alohomora::tarpc::client::TahiniChannel<
                DatabaseTahiniRequest,
                DatabaseTahiniResponse,
            >,
        );
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::clone::Clone for TahiniDatabaseClient {
            #[inline]
            fn clone(&self) -> TahiniDatabaseClient {
                TahiniDatabaseClient(::core::clone::Clone::clone(&self.0))
            }
        }
        impl TahiniDatabaseClient {
            /// Returns a new client stub that sends requests over the given transport.
            pub fn new<T>(
                config: ::tarpc::client::Config,
                transport: T,
            ) -> ::alohomora::tarpc::client::TahiniNewClient<
                Self,
                ::alohomora::tarpc::client::TahiniRequestDispatch<
                    DatabaseTahiniRequest,
                    DatabaseTahiniResponse,
                    T,
                >,
            >
            where
                T: ::tarpc::Transport<
                    ::tarpc::ClientMessage<
                        ::alohomora::tarpc::enums::TahiniSafeWrapper<
                            DatabaseTahiniRequest,
                        >,
                    >,
                    ::tarpc::Response<DatabaseTahiniResponse>,
                >,
            {
                let new_client = ::alohomora::tarpc::client::new(config, transport);
                ::alohomora::tarpc::client::TahiniNewClient {
                    client: TahiniDatabaseClient(new_client.client),
                    dispatch: new_client.dispatch,
                }
            }
            #[allow(unused)]
            pub fn store_prompt(
                &self,
                ctx: ::tarpc::context::Context,
                prompt: DatabaseStoreForm,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<
                    Result<CHATUID, PolicyError>,
                    ::tarpc::client::RpcError,
                >,
            > + '_ {
                let request = DatabaseTahiniRequest::StorePrompt {
                    prompt,
                };
                let resp = self
                    .0
                    .call(ctx, "DatabaseTahiniRequest.StorePrompt", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::StorePrompt(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
            #[allow(unused)]
            pub fn retrieve_prompt(
                &self,
                ctx: ::tarpc::context::Context,
                retrieve: DatabaseRetrieveForm,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<
                    Option<BBoxConversation>,
                    ::tarpc::client::RpcError,
                >,
            > + '_ {
                let request = DatabaseTahiniRequest::RetrievePrompt {
                    retrieve,
                };
                let resp = self
                    .0
                    .call(ctx, "DatabaseTahiniRequest.RetrievePrompt", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::RetrievePrompt(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
            #[allow(unused)]
            pub fn fetch_user(
                &self,
                ctx: ::tarpc::context::Context,
                username: BBox<String, UsernamePolicy>,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<
                    Result<BBox<String, UsernamePolicy>, DatabaseError>,
                    ::tarpc::client::RpcError,
                >,
            > + '_ {
                let request = DatabaseTahiniRequest::FetchUser {
                    username,
                };
                let resp = self.0.call(ctx, "DatabaseTahiniRequest.FetchUser", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::FetchUser(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
            #[allow(unused)]
            pub fn register_user(
                &self,
                ctx: ::tarpc::context::Context,
                username: BBox<String, UsernamePolicy>,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<
                    Result<BBox<String, UsernamePolicy>, DatabaseError>,
                    ::tarpc::client::RpcError,
                >,
            > + '_ {
                let request = DatabaseTahiniRequest::RegisterUser {
                    username,
                };
                let resp = self
                    .0
                    .call(ctx, "DatabaseTahiniRequest.RegisterUser", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::RegisterUser(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
            #[allow(unused)]
            pub fn fetch_history_headers(
                &self,
                ctx: ::tarpc::context::Context,
                username: BBox<String, UsernamePolicy>,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<
                    Vec<BBox<String, ConversationMetadataPolicy>>,
                    ::tarpc::client::RpcError,
                >,
            > + '_ {
                let request = DatabaseTahiniRequest::FetchHistoryHeaders {
                    username,
                };
                let resp = self
                    .0
                    .call(ctx, "DatabaseTahiniRequest.FetchHistoryHeaders", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::FetchHistoryHeaders(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
            #[allow(unused)]
            pub fn get_default_user(
                &self,
                ctx: ::tarpc::context::Context,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<
                    BBox<String, UsernamePolicy>,
                    ::tarpc::client::RpcError,
                >,
            > + '_ {
                let request = DatabaseTahiniRequest::GetDefaultUser {
                };
                let resp = self
                    .0
                    .call(ctx, "DatabaseTahiniRequest.GetDefaultUser", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::GetDefaultUser(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
            #[allow(unused)]
            pub fn delete_conversation(
                &self,
                ctx: ::tarpc::context::Context,
                user_id: BBox<String, UsernamePolicy>,
                conv_id: BBox<String, ConversationMetadataPolicy>,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<bool, ::tarpc::client::RpcError>,
            > + '_ {
                let request = DatabaseTahiniRequest::DeleteConversation {
                    user_id,
                    conv_id,
                };
                let resp = self
                    .0
                    .call(ctx, "DatabaseTahiniRequest.DeleteConversation", request);
                async move {
                    match resp.await? {
                        DatabaseTahiniResponse::DeleteConversation(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
        }
    }
    pub mod marketing {
        use crate::policies::MarketingPolicy;
        use crate::types::marketing_types::{Ad, MarketingData};
        use alohomora::bbox::BBox;
        use alohomora::tahini_service;
        use alohomora::tarpc::{TahiniType, client::TahiniStub};
        pub trait Advertisement: ::core::marker::Sized + Clone {
            async fn auction_bidding(
                self,
                context: ::tarpc::context::Context,
                prompt: BBox<MarketingData, MarketingPolicy>,
            ) -> Ad;
            /// Returns a serving function to use with
            /// [InFlightRequest::execute](::tarpc::server::InFlightRequest::execute).
            fn serve(self) -> ServeAdvertisement<Self> {
                ServeAdvertisement {
                    service: self,
                }
            }
        }
        /// A serving function to use with [::tarpc::server::InFlightRequest::execute].
        pub struct ServeAdvertisement<S> {
            service: S,
        }
        #[automatically_derived]
        impl<S: ::core::clone::Clone> ::core::clone::Clone for ServeAdvertisement<S> {
            #[inline]
            fn clone(&self) -> ServeAdvertisement<S> {
                ServeAdvertisement {
                    service: ::core::clone::Clone::clone(&self.service),
                }
            }
        }
        impl<S> ::alohomora::tarpc::server::TahiniServe for ServeAdvertisement<S>
        where
            S: Advertisement + Clone,
        {
            type Req = AdvertisementTahiniRequest;
            type Resp = AdvertisementTahiniResponse;
            async fn serve(
                self,
                ctx: ::tarpc::context::Context,
                req: AdvertisementTahiniRequest,
            ) -> ::core::result::Result<
                AdvertisementTahiniResponse,
                ::tarpc::ServerError,
            > {
                match req {
                    AdvertisementTahiniRequest::AuctionBidding { prompt } => {
                        ::core::result::Result::Ok(
                            AdvertisementTahiniResponse::AuctionBidding(
                                Advertisement::auction_bidding(self.service, ctx, prompt)
                                    .await,
                            ),
                        )
                    }
                }
            }
        }
        /// The request sent over the wire from the client to the server.
        #[allow(missing_docs)]
        pub enum AdvertisementTahiniRequest {
            AuctionBidding { prompt: BBox<MarketingData, MarketingPolicy> },
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AdvertisementTahiniRequest {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "AuctionBidding" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"AuctionBidding" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            AdvertisementTahiniRequest,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AdvertisementTahiniRequest;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum AdvertisementTahiniRequest",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    #[allow(non_camel_case_types)]
                                    #[doc(hidden)]
                                    enum __Field {
                                        __field0,
                                        __ignore,
                                    }
                                    #[doc(hidden)]
                                    struct __FieldVisitor;
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                        type Value = __Field;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "field identifier",
                                            )
                                        }
                                        fn visit_u64<__E>(
                                            self,
                                            __value: u64,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                0u64 => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_str<__E>(
                                            self,
                                            __value: &str,
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                "prompt" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                        fn visit_bytes<__E>(
                                            self,
                                            __value: &[u8],
                                        ) -> _serde::__private::Result<Self::Value, __E>
                                        where
                                            __E: _serde::de::Error,
                                        {
                                            match __value {
                                                b"prompt" => _serde::__private::Ok(__Field::__field0),
                                                _ => _serde::__private::Ok(__Field::__ignore),
                                            }
                                        }
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::Deserialize<'de> for __Field {
                                        #[inline]
                                        fn deserialize<__D>(
                                            __deserializer: __D,
                                        ) -> _serde::__private::Result<Self, __D::Error>
                                        where
                                            __D: _serde::Deserializer<'de>,
                                        {
                                            _serde::Deserializer::deserialize_identifier(
                                                __deserializer,
                                                __FieldVisitor,
                                            )
                                        }
                                    }
                                    #[doc(hidden)]
                                    struct __Visitor<'de> {
                                        marker: _serde::__private::PhantomData<
                                            AdvertisementTahiniRequest,
                                        >,
                                        lifetime: _serde::__private::PhantomData<&'de ()>,
                                    }
                                    #[automatically_derived]
                                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                        type Value = AdvertisementTahiniRequest;
                                        fn expecting(
                                            &self,
                                            __formatter: &mut _serde::__private::Formatter,
                                        ) -> _serde::__private::fmt::Result {
                                            _serde::__private::Formatter::write_str(
                                                __formatter,
                                                "struct variant AdvertisementTahiniRequest::AuctionBidding",
                                            )
                                        }
                                        #[inline]
                                        fn visit_seq<__A>(
                                            self,
                                            mut __seq: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::SeqAccess<'de>,
                                        {
                                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                                BBox<MarketingData, MarketingPolicy>,
                                            >(&mut __seq)? {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde::__private::Err(
                                                        _serde::de::Error::invalid_length(
                                                            0usize,
                                                            &"struct variant AdvertisementTahiniRequest::AuctionBidding with 1 element",
                                                        ),
                                                    );
                                                }
                                            };
                                            _serde::__private::Ok(AdvertisementTahiniRequest::AuctionBidding {
                                                prompt: __field0,
                                            })
                                        }
                                        #[inline]
                                        fn visit_map<__A>(
                                            self,
                                            mut __map: __A,
                                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                                        where
                                            __A: _serde::de::MapAccess<'de>,
                                        {
                                            let mut __field0: _serde::__private::Option<
                                                BBox<MarketingData, MarketingPolicy>,
                                            > = _serde::__private::None;
                                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                                __Field,
                                            >(&mut __map)? {
                                                match __key {
                                                    __Field::__field0 => {
                                                        if _serde::__private::Option::is_some(&__field0) {
                                                            return _serde::__private::Err(
                                                                <__A::Error as _serde::de::Error>::duplicate_field("prompt"),
                                                            );
                                                        }
                                                        __field0 = _serde::__private::Some(
                                                            _serde::de::MapAccess::next_value::<
                                                                BBox<MarketingData, MarketingPolicy>,
                                                            >(&mut __map)?,
                                                        );
                                                    }
                                                    _ => {
                                                        let _ = _serde::de::MapAccess::next_value::<
                                                            _serde::de::IgnoredAny,
                                                        >(&mut __map)?;
                                                    }
                                                }
                                            }
                                            let __field0 = match __field0 {
                                                _serde::__private::Some(__field0) => __field0,
                                                _serde::__private::None => {
                                                    _serde::__private::de::missing_field("prompt")?
                                                }
                                            };
                                            _serde::__private::Ok(AdvertisementTahiniRequest::AuctionBidding {
                                                prompt: __field0,
                                            })
                                        }
                                    }
                                    #[doc(hidden)]
                                    const FIELDS: &'static [&'static str] = &["prompt"];
                                    _serde::de::VariantAccess::struct_variant(
                                        __variant,
                                        FIELDS,
                                        __Visitor {
                                            marker: _serde::__private::PhantomData::<
                                                AdvertisementTahiniRequest,
                                            >,
                                            lifetime: _serde::__private::PhantomData,
                                        },
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["AuctionBidding"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "AdvertisementTahiniRequest",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                AdvertisementTahiniRequest,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for AdvertisementTahiniRequest {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    AdvertisementTahiniRequest::AuctionBidding { prompt } => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "AdvertisementTahiniRequest",
                            0u32,
                            "AuctionBidding",
                            {
                                ::alohomora::tarpc::enums::TahiniVariantsEnum::Struct(
                                    ::std::collections::HashMap::from([
                                        (
                                            "prompt",
                                            <BBox<
                                                MarketingData,
                                                MarketingPolicy,
                                            > as TahiniType>::to_tahini_enum(prompt),
                                        ),
                                    ]),
                                )
                            },
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    AdvertisementTahiniRequest::AuctionBidding { prompt } => {
                        let mut policy_vec = Vec::new();
                        policy_vec
                            .push(
                                prompt.tahini_policy_check(members_fmt, context, reason),
                            );
                        policy_vec.iter().all(|x: &bool| *x)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for AdvertisementTahiniRequest {
            #[inline]
            fn clone(&self) -> AdvertisementTahiniRequest {
                match self {
                    AdvertisementTahiniRequest::AuctionBidding { prompt: __self_0 } => {
                        AdvertisementTahiniRequest::AuctionBidding {
                            prompt: ::core::clone::Clone::clone(__self_0),
                        }
                    }
                }
            }
        }
        /// The response sent over the wire from the server to the client.
        #[allow(missing_docs)]
        pub enum AdvertisementTahiniResponse {
            AuctionBidding(Ad),
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AdvertisementTahiniResponse {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::invalid_value(
                                            _serde::de::Unexpected::Unsigned(__value),
                                            &"variant index 0 <= i < 1",
                                        ),
                                    )
                                }
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "AuctionBidding" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"AuctionBidding" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(
                                        _serde::de::Error::unknown_variant(__value, VARIANTS),
                                    )
                                }
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            AdvertisementTahiniResponse,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AdvertisementTahiniResponse;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum AdvertisementTahiniResponse",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match _serde::de::EnumAccess::variant(__data)? {
                                (__Field::__field0, __variant) => {
                                    _serde::__private::Result::map(
                                        _serde::de::VariantAccess::newtype_variant::<Ad>(__variant),
                                        AdvertisementTahiniResponse::AuctionBidding,
                                    )
                                }
                            }
                        }
                    }
                    #[doc(hidden)]
                    const VARIANTS: &'static [&'static str] = &["AuctionBidding"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "AdvertisementTahiniResponse",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                AdvertisementTahiniResponse,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        ///Library implementation of TahiniType. Do not copy this docstring!
        impl ::alohomora::tarpc::TahiniType for AdvertisementTahiniResponse {
            fn to_tahini_enum(&self) -> ::alohomora::tarpc::TahiniEnum {
                match self {
                    AdvertisementTahiniResponse::AuctionBidding(x) => {
                        ::alohomora::tarpc::enums::TahiniEnum::Enum(
                            "AdvertisementTahiniResponse",
                            0u32,
                            "AuctionBidding",
                            ::alohomora::tarpc::enums::TahiniVariantsEnum::NewType(
                                Box::new(x.to_tahini_enum()),
                            ),
                        )
                    }
                }
            }
            fn tahini_policy_check(
                &self,
                members_fmt: &String,
                context: &::alohomora::context::UnprotectedContext,
                reason: &::alohomora::policy::Reason,
            ) -> bool {
                match self {
                    AdvertisementTahiniResponse::AuctionBidding(x) => {
                        x.tahini_policy_check(members_fmt, context, reason)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(missing_docs)]
        impl ::core::clone::Clone for AdvertisementTahiniResponse {
            #[inline]
            fn clone(&self) -> AdvertisementTahiniResponse {
                match self {
                    AdvertisementTahiniResponse::AuctionBidding(__self_0) => {
                        AdvertisementTahiniResponse::AuctionBidding(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[allow(unused)]
        /// The client stub that makes RPC calls to the server. All request methods return
        /// [Futures](::core::future::Future).
        pub struct TahiniAdvertisementClient(
            ::alohomora::tarpc::client::TahiniChannel<
                AdvertisementTahiniRequest,
                AdvertisementTahiniResponse,
            >,
        );
        #[automatically_derived]
        #[allow(unused)]
        impl ::core::clone::Clone for TahiniAdvertisementClient {
            #[inline]
            fn clone(&self) -> TahiniAdvertisementClient {
                TahiniAdvertisementClient(::core::clone::Clone::clone(&self.0))
            }
        }
        impl TahiniAdvertisementClient {
            /// Returns a new client stub that sends requests over the given transport.
            pub fn new<T>(
                config: ::tarpc::client::Config,
                transport: T,
            ) -> ::alohomora::tarpc::client::TahiniNewClient<
                Self,
                ::alohomora::tarpc::client::TahiniRequestDispatch<
                    AdvertisementTahiniRequest,
                    AdvertisementTahiniResponse,
                    T,
                >,
            >
            where
                T: ::tarpc::Transport<
                    ::tarpc::ClientMessage<
                        ::alohomora::tarpc::enums::TahiniSafeWrapper<
                            AdvertisementTahiniRequest,
                        >,
                    >,
                    ::tarpc::Response<AdvertisementTahiniResponse>,
                >,
            {
                let new_client = ::alohomora::tarpc::client::new(config, transport);
                ::alohomora::tarpc::client::TahiniNewClient {
                    client: TahiniAdvertisementClient(new_client.client),
                    dispatch: new_client.dispatch,
                }
            }
            #[allow(unused)]
            pub fn auction_bidding(
                &self,
                ctx: ::tarpc::context::Context,
                prompt: BBox<MarketingData, MarketingPolicy>,
            ) -> impl ::core::future::Future<
                Output = ::core::result::Result<Ad, ::tarpc::client::RpcError>,
            > + '_ {
                let request = AdvertisementTahiniRequest::AuctionBidding {
                    prompt,
                };
                let resp = self
                    .0
                    .call(ctx, "AdvertisementTahiniRequest.AuctionBidding", request);
                async move {
                    match resp.await? {
                        AdvertisementTahiniResponse::AuctionBidding(msg) => {
                            ::core::result::Result::Ok(msg)
                        }
                        _ => {
                            ::core::panicking::panic(
                                "internal error: entered unreachable code",
                            )
                        }
                    }
                }
            }
        }
    }
}
pub mod policies {
    pub mod inference_policy {
        use alohomora::db::{BBoxFromValue, Value};
        use alohomora::policy::{AnyPolicy, PolicyAnd, schema_policy};
        use alohomora::{
            policy::{FrontendPolicy, Policy, Reason, SchemaPolicy},
            rocket::{RocketCookie, RocketRequest},
        };
        use serde_json::from_str;
        use std::collections::HashMap;
        use std::str::FromStr;
        use tarpc::serde::{Deserialize, Serialize};
        use super::marketing_policy::THIRD_PARTY_PROCESSORS;
        use super::shared_policies::UsernamePolicy;
        ///This policy is invoked when the use of conversation/message information
        ///Three main fields are invoked here:
        ///The storage to database (i.e. ephemeral chats)
        ///Allowing to send anonymized data to Tahini-fied third-parties
        ///Allowing the use of unprotected third-party services (e.g. image gen)
        pub struct PromptPolicy {
            pub storage: bool,
            pub marketing_consent: bool,
            pub third_party_consent: HashMap<String, bool>,
            pub unprotected_image_gen: bool,
        }
        #[used]
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        #[link_section = ".init_array"]
        static ___register_PromptPolicy_conversations_4___ctor: unsafe extern "C" fn() = {
            #[link_section = ".text.startup"]
            unsafe extern "C" fn ___register_PromptPolicy_conversations_4___ctor() {
                register_PromptPolicy_conversations_4()
            }
            ___register_PromptPolicy_conversations_4___ctor
        };
        unsafe fn register_PromptPolicy_conversations_4() {
            ::alohomora::policy::add_schema_policy::<
                PromptPolicy,
            >(::std::string::String::from("conversations"), 4usize);
        }
        #[used]
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        #[link_section = ".init_array"]
        static ___register_PromptPolicy_conversations_3___ctor: unsafe extern "C" fn() = {
            #[link_section = ".text.startup"]
            unsafe extern "C" fn ___register_PromptPolicy_conversations_3___ctor() {
                register_PromptPolicy_conversations_3()
            }
            ___register_PromptPolicy_conversations_3___ctor
        };
        unsafe fn register_PromptPolicy_conversations_3() {
            ::alohomora::policy::add_schema_policy::<
                PromptPolicy,
            >(::std::string::String::from("conversations"), 3usize);
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PromptPolicy {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "PromptPolicy",
                        false as usize + 1 + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "storage",
                        &self.storage,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "marketing_consent",
                        &self.marketing_consent,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "third_party_consent",
                        &self.third_party_consent,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "unprotected_image_gen",
                        &self.unprotected_image_gen,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PromptPolicy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "storage" => _serde::__private::Ok(__Field::__field0),
                                "marketing_consent" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "third_party_consent" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                "unprotected_image_gen" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"storage" => _serde::__private::Ok(__Field::__field0),
                                b"marketing_consent" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"third_party_consent" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                b"unprotected_image_gen" => {
                                    _serde::__private::Ok(__Field::__field3)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PromptPolicy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PromptPolicy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PromptPolicy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PromptPolicy with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PromptPolicy with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                HashMap<String, bool>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct PromptPolicy with 4 elements",
                                        ),
                                    );
                                }
                            };
                            let __field3 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            3usize,
                                            &"struct PromptPolicy with 4 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PromptPolicy {
                                storage: __field0,
                                marketing_consent: __field1,
                                third_party_consent: __field2,
                                unprotected_image_gen: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                HashMap<String, bool>,
                            > = _serde::__private::None;
                            let mut __field3: _serde::__private::Option<bool> = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "storage",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "marketing_consent",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "third_party_consent",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                HashMap<String, bool>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::__private::Option::is_some(&__field3) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unprotected_image_gen",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("storage")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("marketing_consent")?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("third_party_consent")?
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::__private::Some(__field3) => __field3,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "unprotected_image_gen",
                                    )?
                                }
                            };
                            _serde::__private::Ok(PromptPolicy {
                                storage: __field0,
                                marketing_consent: __field1,
                                third_party_consent: __field2,
                                unprotected_image_gen: __field3,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "storage",
                        "marketing_consent",
                        "third_party_consent",
                        "unprotected_image_gen",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PromptPolicy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PromptPolicy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for PromptPolicy {
            #[inline]
            fn clone(&self) -> PromptPolicy {
                PromptPolicy {
                    storage: ::core::clone::Clone::clone(&self.storage),
                    marketing_consent: ::core::clone::Clone::clone(
                        &self.marketing_consent,
                    ),
                    third_party_consent: ::core::clone::Clone::clone(
                        &self.third_party_consent,
                    ),
                    unprotected_image_gen: ::core::clone::Clone::clone(
                        &self.unprotected_image_gen,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for PromptPolicy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field4_finish(
                    f,
                    "PromptPolicy",
                    "storage",
                    &self.storage,
                    "marketing_consent",
                    &self.marketing_consent,
                    "third_party_consent",
                    &self.third_party_consent,
                    "unprotected_image_gen",
                    &&self.unprotected_image_gen,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for PromptPolicy {
            #[inline]
            fn default() -> PromptPolicy {
                PromptPolicy {
                    storage: ::core::default::Default::default(),
                    marketing_consent: ::core::default::Default::default(),
                    third_party_consent: ::core::default::Default::default(),
                    unprotected_image_gen: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for PromptPolicy {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for PromptPolicy {
            #[inline]
            fn eq(&self, other: &PromptPolicy) -> bool {
                self.storage == other.storage
                    && self.marketing_consent == other.marketing_consent
                    && self.third_party_consent == other.third_party_consent
                    && self.unprotected_image_gen == other.unprotected_image_gen
            }
        }
        impl Policy for PromptPolicy {
            fn name(&self) -> String {
                "PromptPolicy".to_string()
            }
            fn check(
                &self,
                context: &alohomora::context::UnprotectedContext,
                reason: alohomora::policy::Reason<'_>,
            ) -> bool {
                match reason {
                    Reason::DB(_, _) => self.storage,
                    Reason::Response => true,
                    Reason::Custom(reason) => {
                        match reason.cast().downcast_ref::<InferenceReason>() {
                            None => false,
                            Some(reason) => {
                                match reason {
                                    InferenceReason::SendToMarketing => self.marketing_consent,
                                    InferenceReason::SendToImageGen => {
                                        self.unprotected_image_gen
                                    }
                                    InferenceReason::SendToDB => self.storage,
                                }
                            }
                        }
                    }
                    _ => false,
                }
            }
            fn join(
                &self,
                other: alohomora::policy::AnyPolicy,
            ) -> Result<alohomora::policy::AnyPolicy, ()> {
                if other.is::<PromptPolicy>() {
                    self.join_logic(other.specialize().map_err(|_| ())?)
                        .map(|pol| pol.into_any())
                } else if other.is::<UsernamePolicy>() {
                    let spec = other.specialize::<UsernamePolicy>();
                    if spec.is_err() {
                        return Err(());
                    }
                    Ok(AnyPolicy::new(PolicyAnd::new(self.clone(), spec.unwrap())))
                } else {
                    Ok(AnyPolicy::new(PolicyAnd::new(self.clone(), other)))
                }
            }
            fn join_logic(&self, other: Self) -> Result<Self, ()>
            where
                Self: Sized,
            {
                let mut hashmap = self.third_party_consent.clone();
                for (key, value) in other.third_party_consent.iter() {
                    hashmap
                        .entry(key.clone())
                        .and_modify(|e| *e = *e && *value)
                        .or_insert(*value);
                }
                Ok(PromptPolicy {
                    third_party_consent: hashmap,
                    storage: self.storage && other.storage,
                    marketing_consent: self.marketing_consent && other.marketing_consent,
                    unprotected_image_gen: self.unprotected_image_gen
                        && other.unprotected_image_gen,
                })
            }
            fn into_any(self) -> alohomora::policy::AnyPolicy
            where
                Self: Sized,
            {
                AnyPolicy::new(self)
            }
        }
        pub enum InferenceReason {
            SendToMarketing,
            SendToImageGen,
            SendToDB,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for InferenceReason {
            #[inline]
            fn clone(&self) -> InferenceReason {
                match self {
                    InferenceReason::SendToMarketing => InferenceReason::SendToMarketing,
                    InferenceReason::SendToImageGen => InferenceReason::SendToImageGen,
                    InferenceReason::SendToDB => InferenceReason::SendToDB,
                }
            }
        }
        impl FrontendPolicy for PromptPolicy {
            fn from_request<'a, 'r>(request: &'a RocketRequest<'r>) -> Self
            where
                Self: Sized,
            {
                let no_storage = bool::from_str(
                        request.cookies().get("storage").unwrap().value(),
                    )
                    .unwrap();
                let marketing_consent = bool::from_str(
                        request.cookies().get("ads").unwrap().value(),
                    )
                    .unwrap();
                let unprotected_image_gen = bool::from_str(
                        request.cookies().get("image_gen").unwrap().value(),
                    )
                    .unwrap();
                let mut hashmap = HashMap::with_capacity(THIRD_PARTY_PROCESSORS.len());
                for vendor in THIRD_PARTY_PROCESSORS {
                    let cookie = request.cookies().get(vendor);
                    hashmap
                        .insert(
                            vendor.to_string(),
                            match cookie {
                                None => false,
                                Some(c) => bool::from_str(c.value()).unwrap_or(false),
                            },
                        );
                }
                PromptPolicy {
                    third_party_consent: hashmap,
                    storage: no_storage,
                    marketing_consent,
                    unprotected_image_gen,
                }
            }
            fn from_cookie<'a, 'r>(
                name: &str,
                cookie: &'a RocketCookie<'static>,
                request: &'a RocketRequest<'r>,
            ) -> Self
            where
                Self: Sized,
            {
                Self::from_request(request)
            }
        }
        impl SchemaPolicy for PromptPolicy {
            fn from_row(table_name: &str, row: &Vec<Value>) -> Self
            where
                Self: Sized,
            {
                let value = <String as BBoxFromValue>::from_value(row[9].clone());
                let hashmap = match from_str(value.as_str()) {
                    Ok(map) => map,
                    Err(_) => {
                        {
                            ::std::io::_eprint(
                                format_args!(
                                    "Couldn\'t parse consent table into the proper type, got {0}\n",
                                    value,
                                ),
                            );
                        };
                        HashMap::<String, bool>::new()
                    }
                };
                PromptPolicy {
                    third_party_consent: hashmap,
                    storage: BBoxFromValue::from_value(row[5].clone()),
                    marketing_consent: BBoxFromValue::from_value(row[6].clone()),
                    unprotected_image_gen: BBoxFromValue::from_value(row[7].clone()),
                }
            }
        }
    }
    pub mod database_policy {
        use alohomora::db::{BBoxFromValue, Value};
        use alohomora::policy::{schema_policy, AnyPolicy, PolicyAnd};
        use alohomora::{
            policy::{FrontendPolicy, Policy, Reason, SchemaPolicy},
            rocket::{RocketCookie, RocketRequest},
        };
        use std::str::FromStr;
        use tarpc::serde::{Deserialize, Serialize};
        ///A policy for conversational metadata (such as conversation id)
        ///Only allows for authenticated disclosure, and even so, only on specific routes.
        ///While extensible, this policy aims to be used in a user-only context, i.e., no disclosure
        ///to any third-parties.
        pub struct ConversationMetadataPolicy {}
        #[used]
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        #[link_section = ".init_array"]
        static ___register_ConversationMetadataPolicy_conversations_1___ctor: unsafe extern "C" fn() = {
            #[link_section = ".text.startup"]
            unsafe extern "C" fn ___register_ConversationMetadataPolicy_conversations_1___ctor() {
                register_ConversationMetadataPolicy_conversations_1()
            }
            ___register_ConversationMetadataPolicy_conversations_1___ctor
        };
        unsafe fn register_ConversationMetadataPolicy_conversations_1() {
            ::alohomora::policy::add_schema_policy::<
                ConversationMetadataPolicy,
            >(::std::string::String::from("conversations"), 1usize);
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ConversationMetadataPolicy {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "ConversationMetadataPolicy",
                        false as usize,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ConversationMetadataPolicy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<
                            ConversationMetadataPolicy,
                        >,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ConversationMetadataPolicy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct ConversationMetadataPolicy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(ConversationMetadataPolicy {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            _serde::__private::Ok(ConversationMetadataPolicy {})
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ConversationMetadataPolicy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<
                                ConversationMetadataPolicy,
                            >,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for ConversationMetadataPolicy {
            #[inline]
            fn clone(&self) -> ConversationMetadataPolicy {
                ConversationMetadataPolicy {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for ConversationMetadataPolicy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "ConversationMetadataPolicy")
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for ConversationMetadataPolicy {
            #[inline]
            fn default() -> ConversationMetadataPolicy {
                ConversationMetadataPolicy {}
            }
        }
        impl Policy for ConversationMetadataPolicy {
            fn name(&self) -> String {
                "ConversationMetadataPolicy".to_string()
            }
            fn check(
                &self,
                context: &alohomora::context::UnprotectedContext,
                reason: Reason<'_>,
            ) -> bool {
                match reason {
                    Reason::DB(_, _) => true,
                    Reason::Response => {
                        match context.route.as_str() {
                            "history" => {
                                match context.data.downcast_ref::<bool>() {
                                    None => false,
                                    Some(auth) => *auth,
                                }
                            }
                            _ => true,
                        }
                    }
                    _ => false,
                }
            }
            fn join(&self, other: AnyPolicy) -> Result<AnyPolicy, ()> {
                if other.is::<ConversationMetadataPolicy>() {
                    Ok(other)
                } else {
                    Ok(
                        AnyPolicy::new(
                            PolicyAnd::new(AnyPolicy::new(self.clone()), other),
                        ),
                    )
                }
            }
            fn join_logic(&self, other: Self) -> Result<Self, ()>
            where
                Self: Sized,
            {
                Ok(other)
            }
            fn into_any(self) -> AnyPolicy
            where
                Self: Sized,
            {
                AnyPolicy::new(self)
            }
        }
        impl SchemaPolicy for ConversationMetadataPolicy {
            fn from_row(table_name: &str, row: &Vec<Value>) -> Self
            where
                Self: Sized,
            {
                Self {}
            }
        }
        impl FrontendPolicy for ConversationMetadataPolicy {
            fn from_cookie<'a, 'r>(
                name: &str,
                cookie: &'a RocketCookie<'static>,
                request: &'a RocketRequest<'r>,
            ) -> Self
            where
                Self: Sized,
            {
                Self {}
            }
            fn from_request<'a, 'r>(request: &'a RocketRequest<'r>) -> Self
            where
                Self: Sized,
            {
                Self {}
            }
        }
    }
    pub mod marketing_policy {
        use std::collections::HashMap;
        use alohomora::policy::{Policy, Reason};
        use tarpc::serde::{Deserialize, Serialize};
        pub static THIRD_PARTY_PROCESSORS: [&str; 2] = ["Meta_Ads", "Google_Ads"];
        ///This policy is given by an external organization so that remote clients can
        ///be compatible with it. This policies contains:
        ///- A storage consent
        ///- A targeted ads consent (.e.g, locally processed but still sent to the particular user)
        ///- Consent for various next-hops services.
        ///
        ///Note the lack of information regarding unprotected services (yet)
        pub struct MarketingPolicy {
            pub no_storage: bool,
            pub targeted_ads_consent: bool,
            pub third_party_processing: HashMap<String, bool>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for MarketingPolicy {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "MarketingPolicy",
                        false as usize + 1 + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "no_storage",
                        &self.no_storage,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "targeted_ads_consent",
                        &self.targeted_ads_consent,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "third_party_processing",
                        &self.third_party_processing,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for MarketingPolicy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "no_storage" => _serde::__private::Ok(__Field::__field0),
                                "targeted_ads_consent" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                "third_party_processing" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"no_storage" => _serde::__private::Ok(__Field::__field0),
                                b"targeted_ads_consent" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                b"third_party_processing" => {
                                    _serde::__private::Ok(__Field::__field2)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<MarketingPolicy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = MarketingPolicy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct MarketingPolicy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct MarketingPolicy with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct MarketingPolicy with 3 elements",
                                        ),
                                    );
                                }
                            };
                            let __field2 = match _serde::de::SeqAccess::next_element::<
                                HashMap<String, bool>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct MarketingPolicy with 3 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(MarketingPolicy {
                                no_storage: __field0,
                                targeted_ads_consent: __field1,
                                third_party_processing: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field2: _serde::__private::Option<
                                HashMap<String, bool>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "no_storage",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "targeted_ads_consent",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::__private::Option::is_some(&__field2) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "third_party_processing",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                HashMap<String, bool>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field("no_storage")?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "targeted_ads_consent",
                                    )?
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::__private::Some(__field2) => __field2,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "third_party_processing",
                                    )?
                                }
                            };
                            _serde::__private::Ok(MarketingPolicy {
                                no_storage: __field0,
                                targeted_ads_consent: __field1,
                                third_party_processing: __field2,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "no_storage",
                        "targeted_ads_consent",
                        "third_party_processing",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "MarketingPolicy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<MarketingPolicy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for MarketingPolicy {
            #[inline]
            fn clone(&self) -> MarketingPolicy {
                MarketingPolicy {
                    no_storage: ::core::clone::Clone::clone(&self.no_storage),
                    targeted_ads_consent: ::core::clone::Clone::clone(
                        &self.targeted_ads_consent,
                    ),
                    third_party_processing: ::core::clone::Clone::clone(
                        &self.third_party_processing,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for MarketingPolicy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field3_finish(
                    f,
                    "MarketingPolicy",
                    "no_storage",
                    &self.no_storage,
                    "targeted_ads_consent",
                    &self.targeted_ads_consent,
                    "third_party_processing",
                    &&self.third_party_processing,
                )
            }
        }
        impl Policy for MarketingPolicy {
            fn name(&self) -> String {
                "MarketingPolicy".to_string()
            }
            fn check(
                &self,
                context: &alohomora::context::UnprotectedContext,
                reason: alohomora::policy::Reason<'_>,
            ) -> bool {
                match reason {
                    Reason::DB(_, _) => !self.no_storage,
                    Reason::Response => true,
                    Reason::Custom(reason) => {
                        match reason.cast().downcast_ref::<MarketingReason>() {
                            None => {
                                {
                                    ::std::io::_print(
                                        format_args!(
                                            "We are failing the downcast to MarketingReason\n",
                                        ),
                                    );
                                };
                                false
                            }
                            Some(reason) => {
                                match reason {
                                    MarketingReason::Email => self.targeted_ads_consent,
                                    MarketingReason::ThirdPartyProcessing(vendor) => {
                                        match self.third_party_processing.get(vendor) {
                                            None => false,
                                            Some(b) => *b,
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _ => {
                        {
                            ::std::io::_print(
                                format_args!("We are invoking for no good reason!\n"),
                            );
                        };
                        false
                    }
                }
            }
            fn join(
                &self,
                other: alohomora::policy::AnyPolicy,
            ) -> Result<alohomora::policy::AnyPolicy, ()> {
                Ok(other)
            }
            fn join_logic(&self, other: Self) -> Result<Self, ()>
            where
                Self: Sized,
            {
                Ok(self.clone())
            }
        }
        pub struct AdPolicy {}
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for AdPolicy {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "AdPolicy",
                        false as usize,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for AdPolicy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<AdPolicy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = AdPolicy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct AdPolicy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::__private::Ok(AdPolicy {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            _serde::__private::Ok(AdPolicy {})
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "AdPolicy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<AdPolicy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for AdPolicy {
            #[inline]
            fn clone(&self) -> AdPolicy {
                AdPolicy {}
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for AdPolicy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::write_str(f, "AdPolicy")
            }
        }
        pub enum MarketingReason {
            Email,
            ThirdPartyProcessing(String),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for MarketingReason {
            #[inline]
            fn clone(&self) -> MarketingReason {
                match self {
                    MarketingReason::Email => MarketingReason::Email,
                    MarketingReason::ThirdPartyProcessing(__self_0) => {
                        MarketingReason::ThirdPartyProcessing(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
    }
    pub mod shared_policies {
        use crate::policies::inference_policy::InferenceReason;
        use crate::policies::marketing_policy::THIRD_PARTY_PROCESSORS;
        use alohomora::db::{BBoxFromValue, Value, from_value};
        use alohomora::policy::{
            AnyPolicy, FrontendPolicy, NoPolicy, Policy, PolicyAnd, PolicyTransformable,
            Reason, SchemaPolicy, schema_policy,
        };
        use alohomora::rocket::{BBoxCookie, RocketCookie, RocketRequest};
        use alohomora::tarpc::context::TahiniContext;
        use serde_json::from_str;
        use std::collections::HashMap;
        use std::str::FromStr;
        use tarpc::serde::{Deserialize, Serialize};
        use super::{MarketingPolicy, PromptPolicy};
        ///This policy is user-and-session-bound and
        ///is invoked in operations that could lead to current-or-future disclosure of the username
        pub struct UsernamePolicy {
            pub targeted_ads_consent: bool,
            pub third_party_vendors_consent: HashMap<String, bool>,
        }
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for UsernamePolicy {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = _serde::Serializer::serialize_struct(
                        __serializer,
                        "UsernamePolicy",
                        false as usize + 1 + 1,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "targeted_ads_consent",
                        &self.targeted_ads_consent,
                    )?;
                    _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "third_party_vendors_consent",
                        &self.third_party_vendors_consent,
                    )?;
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(
            non_upper_case_globals,
            unused_attributes,
            unused_qualifications,
            clippy::absolute_paths,
        )]
        const _: () = {
            #[allow(unused_extern_crates, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for UsernamePolicy {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    #[doc(hidden)]
                    struct __FieldVisitor;
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "field identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "targeted_ads_consent" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                "third_party_vendors_consent" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"targeted_ads_consent" => {
                                    _serde::__private::Ok(__Field::__field0)
                                }
                                b"third_party_vendors_consent" => {
                                    _serde::__private::Ok(__Field::__field1)
                                }
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    #[automatically_derived]
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    #[doc(hidden)]
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<UsernamePolicy>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    #[automatically_derived]
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = UsernamePolicy;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct UsernamePolicy",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match _serde::de::SeqAccess::next_element::<
                                bool,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct UsernamePolicy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match _serde::de::SeqAccess::next_element::<
                                HashMap<String, bool>,
                            >(&mut __seq)? {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct UsernamePolicy with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(UsernamePolicy {
                                targeted_ads_consent: __field0,
                                third_party_vendors_consent: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<bool> = _serde::__private::None;
                            let mut __field1: _serde::__private::Option<
                                HashMap<String, bool>,
                            > = _serde::__private::None;
                            while let _serde::__private::Some(__key) = _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map)? {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "targeted_ads_consent",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<bool>(&mut __map)?,
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "third_party_vendors_consent",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            _serde::de::MapAccess::next_value::<
                                                HashMap<String, bool>,
                                            >(&mut __map)?,
                                        );
                                    }
                                    _ => {
                                        let _ = _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(&mut __map)?;
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "targeted_ads_consent",
                                    )?
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    _serde::__private::de::missing_field(
                                        "third_party_vendors_consent",
                                    )?
                                }
                            };
                            _serde::__private::Ok(UsernamePolicy {
                                targeted_ads_consent: __field0,
                                third_party_vendors_consent: __field1,
                            })
                        }
                    }
                    #[doc(hidden)]
                    const FIELDS: &'static [&'static str] = &[
                        "targeted_ads_consent",
                        "third_party_vendors_consent",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "UsernamePolicy",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<UsernamePolicy>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        impl ::core::clone::Clone for UsernamePolicy {
            #[inline]
            fn clone(&self) -> UsernamePolicy {
                UsernamePolicy {
                    targeted_ads_consent: ::core::clone::Clone::clone(
                        &self.targeted_ads_consent,
                    ),
                    third_party_vendors_consent: ::core::clone::Clone::clone(
                        &self.third_party_vendors_consent,
                    ),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for UsernamePolicy {
            #[inline]
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "UsernamePolicy",
                    "targeted_ads_consent",
                    &self.targeted_ads_consent,
                    "third_party_vendors_consent",
                    &&self.third_party_vendors_consent,
                )
            }
        }
        #[automatically_derived]
        impl ::core::default::Default for UsernamePolicy {
            #[inline]
            fn default() -> UsernamePolicy {
                UsernamePolicy {
                    targeted_ads_consent: ::core::default::Default::default(),
                    third_party_vendors_consent: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for UsernamePolicy {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for UsernamePolicy {
            #[inline]
            fn eq(&self, other: &UsernamePolicy) -> bool {
                self.targeted_ads_consent == other.targeted_ads_consent
                    && self.third_party_vendors_consent
                        == other.third_party_vendors_consent
            }
        }
        #[used]
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        #[link_section = ".init_array"]
        static ___register_UsernamePolicy_conversations_2___ctor: unsafe extern "C" fn() = {
            #[link_section = ".text.startup"]
            unsafe extern "C" fn ___register_UsernamePolicy_conversations_2___ctor() {
                register_UsernamePolicy_conversations_2()
            }
            ___register_UsernamePolicy_conversations_2___ctor
        };
        unsafe fn register_UsernamePolicy_conversations_2() {
            ::alohomora::policy::add_schema_policy::<
                UsernamePolicy,
            >(::std::string::String::from("conversations"), 2usize);
        }
        #[used]
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        #[link_section = ".init_array"]
        static ___register_UsernamePolicy_users_1___ctor: unsafe extern "C" fn() = {
            #[link_section = ".text.startup"]
            unsafe extern "C" fn ___register_UsernamePolicy_users_1___ctor() {
                register_UsernamePolicy_users_1()
            }
            ___register_UsernamePolicy_users_1___ctor
        };
        unsafe fn register_UsernamePolicy_users_1() {
            ::alohomora::policy::add_schema_policy::<
                UsernamePolicy,
            >(::std::string::String::from("users"), 1usize);
        }
        #[used]
        #[doc(hidden)]
        #[allow(non_upper_case_globals)]
        #[link_section = ".init_array"]
        static ___register_UsernamePolicy_users_0___ctor: unsafe extern "C" fn() = {
            #[link_section = ".text.startup"]
            unsafe extern "C" fn ___register_UsernamePolicy_users_0___ctor() {
                register_UsernamePolicy_users_0()
            }
            ___register_UsernamePolicy_users_0___ctor
        };
        unsafe fn register_UsernamePolicy_users_0() {
            ::alohomora::policy::add_schema_policy::<
                UsernamePolicy,
            >(::std::string::String::from("users"), 0usize);
        }
        impl Policy for UsernamePolicy {
            fn name(&self) -> String {
                "UsernamePolicy".to_string()
            }
            fn check(
                &self,
                context: &alohomora::context::UnprotectedContext,
                reason: Reason<'_>,
            ) -> bool {
                match reason {
                    Reason::Response => true,
                    Reason::DB(_, _) => true,
                    Reason::Custom(reason) => {
                        match reason.cast().downcast_ref::<InferenceReason>() {
                            None => false,
                            Some(reason) => {
                                match reason {
                                    InferenceReason::SendToMarketing => {
                                        self.targeted_ads_consent
                                    }
                                    _ => false,
                                }
                            }
                        }
                    }
                    _ => false,
                }
            }
            fn join(
                &self,
                other: alohomora::policy::AnyPolicy,
            ) -> Result<alohomora::policy::AnyPolicy, ()> {
                if other.is::<UsernamePolicy>() {
                    self.join_logic(other.specialize().map_err(|_| ())?)
                        .map(|p| AnyPolicy::new(p))
                } else if other.is::<PromptPolicy>() {
                    let spec = other.specialize::<PromptPolicy>();
                    if spec.is_err() {
                        return Err(());
                    }
                    Ok(AnyPolicy::new(PolicyAnd::new(self.clone(), spec.unwrap())))
                } else {
                    Ok(AnyPolicy::new(PolicyAnd::new(self.clone(), other)))
                }
            }
            fn join_logic(&self, other: Self) -> Result<Self, ()>
            where
                Self: Sized,
            {
                Ok(self.clone())
            }
            fn into_any(self) -> AnyPolicy
            where
                Self: Sized,
            {
                AnyPolicy::new(self)
            }
        }
        impl SchemaPolicy for UsernamePolicy {
            fn from_row(table_name: &str, row: &Vec<Value>) -> Self
            where
                Self: Sized,
            {
                let value = match table_name {
                    "users" => <String as BBoxFromValue>::from_value(row[3].clone()),
                    "conversations" => {
                        <String as BBoxFromValue>::from_value(row[9].clone())
                    }
                    _ => "{}".to_string(),
                };
                let hashmap = match from_str(value.as_str()) {
                    Ok(map) => map,
                    Err(_) => {
                        {
                            ::std::io::_eprint(
                                format_args!(
                                    "Couldn\'t parse consent table into the proper type, got {0}\n",
                                    value,
                                ),
                            );
                        };
                        HashMap::<String, bool>::new()
                    }
                };
                Self {
                    third_party_vendors_consent: hashmap,
                    targeted_ads_consent: match table_name {
                        "users" => BBoxFromValue::from_value(row[2].clone()),
                        "conversations" => BBoxFromValue::from_value(row[8].clone()),
                        _ => false,
                    },
                }
            }
        }
        impl FrontendPolicy for UsernamePolicy {
            fn from_cookie<'a, 'r>(
                name: &str,
                cookie: &'a RocketCookie<'static>,
                request: &'a RocketRequest<'r>,
            ) -> Self
            where
                Self: Sized,
            {
                let mut hashmap = HashMap::with_capacity(THIRD_PARTY_PROCESSORS.len());
                for vendor in THIRD_PARTY_PROCESSORS {
                    let cookie = request.cookies().get(vendor);
                    hashmap
                        .insert(
                            vendor.to_string(),
                            match cookie {
                                None => false,
                                Some(c) => bool::from_str(c.value()).unwrap_or(false),
                            },
                        );
                }
                UsernamePolicy {
                    third_party_vendors_consent: hashmap,
                    targeted_ads_consent: match request.cookies().get("targeted_ads") {
                        None => false,
                        Some(c) => {
                            match bool::from_str(c.value()) {
                                Ok(b) => b,
                                Err(_) => false,
                            }
                        }
                    },
                }
            }
            fn from_request<'a, 'r>(request: &'a RocketRequest<'r>) -> Self
            where
                Self: Sized,
            {
                let mut hashmap = HashMap::with_capacity(THIRD_PARTY_PROCESSORS.len());
                for vendor in THIRD_PARTY_PROCESSORS {
                    let cookie = request.cookies().get(vendor);
                    hashmap
                        .insert(
                            vendor.to_string(),
                            match cookie {
                                None => false,
                                Some(c) => bool::from_str(c.value()).unwrap_or(false),
                            },
                        );
                }
                UsernamePolicy {
                    third_party_vendors_consent: hashmap,
                    targeted_ads_consent: match request.cookies().get("targeted_ads") {
                        None => false,
                        Some(c) => {
                            match bool::from_str(c.value()) {
                                Ok(b) => b,
                                Err(_) => false,
                            }
                        }
                    },
                }
            }
        }
        ///Used for internal processing. Can be passed around at unchecked RPCs, but can never leave the
        ///org nor be passed to checked RPCs.
        ///Such a policy can ensure that data paths terminating in an uncontrolled sink are taken into
        ///account.
        pub struct AbsolutePolicy {}
        #[automatically_derived]
        impl ::core::clone::Clone for AbsolutePolicy {
            #[inline]
            fn clone(&self) -> AbsolutePolicy {
                AbsolutePolicy {}
            }
        }
        impl Policy for AbsolutePolicy {
            fn name(&self) -> String {
                "AbsolutePolicy".to_string()
            }
            fn check(
                &self,
                context: &alohomora::context::UnprotectedContext,
                reason: Reason<'_>,
            ) -> bool {
                false
            }
            fn join(
                &self,
                other: alohomora::policy::AnyPolicy,
            ) -> Result<alohomora::policy::AnyPolicy, ()> {
                Ok(self.clone().into_any())
            }
            fn join_logic(&self, other: Self) -> Result<Self, ()>
            where
                Self: Sized,
            {
                Ok(other)
            }
            fn into_any(self) -> alohomora::policy::AnyPolicy
            where
                Self: Sized,
            {
                AnyPolicy::new(self)
            }
        }
        impl PolicyTransformable<MarketingPolicy>
        for PolicyAnd<UsernamePolicy, PromptPolicy> {
            fn transform_into(
                &self,
                context: TahiniContext,
            ) -> Result<MarketingPolicy, String> {
                let (p1, p2) = self.extract_policies();
                match context.service.as_str() {
                    "Advertisement" => {
                        match context.rpc.as_str() {
                            "auction_bidding" => {
                                Ok(MarketingPolicy {
                                    no_storage: p2.storage,
                                    targeted_ads_consent: p1.targeted_ads_consent,
                                    third_party_processing: p2.third_party_consent.clone(),
                                })
                            }
                            _ => {
                                Err("Transformation not allowed for this RPC".to_string())
                            }
                        }
                    }
                    _ => Err("Transformation not allowed for this service".to_string()),
                }
            }
        }
    }
    pub use inference_policy::PromptPolicy;
    pub use database_policy::*;
    pub use marketing_policy::MarketingPolicy;
}
pub mod funcs {
    use crate::types::inference_types::{LLMError, Message};
    pub fn validate_user(role: String) -> Result<String, LLMError> {
        match role.as_str() {
            role @ ("user" | "model") => Ok(role.to_string()),
            role @ _ => {
                {
                    ::std::io::_print(
                        format_args!("Role is not that expected: Got {0}\n", role),
                    );
                };
                Err(LLMError::ValidationError)
            }
        }
    }
    pub fn validate_body(body: String) -> Result<String, LLMError> {
        match !(body.contains("<start_of_turn>") || body.contains("<end_of_turn>")) {
            true => Ok(body),
            false => {
                {
                    ::std::io::_print(format_args!("Body is : {0}\n", body));
                };
                Err(LLMError::ValidationError)
            }
        }
    }
    pub fn parse_message(message: Message) -> Result<String, LLMError> {
        Ok(
            ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!(
                        "<start_of_turn>{0}\n{1}<end_of_turn>\n",
                        validate_user(message.role)?,
                        validate_body(message.content)?,
                    ),
                );
                res
            }),
        )
    }
    pub fn parse_conversation(conv: Vec<Message>) -> Result<String, LLMError> {
        conv.into_iter()
            .map(|x| parse_message(x.clone()))
            .collect::<Result<Vec<_>, LLMError>>()
            .map(|mut vec| {
                vec.push("<start_of_turn>model\n".to_string());
                vec
            })
            .map(|vec| vec.join(""))
    }
    pub fn parse_stored_conversation(
        stored_conv: String,
    ) -> Result<Vec<Message>, LLMError> {
        let mut messages = Vec::new();
        let parts = stored_conv.split("<start_of_turn>").collect::<Vec<_>>();
        for part in parts.iter().skip(1) {
            match part.split_once('\n') {
                Some((role, rest)) => {
                    match rest.split_once("<end_of_turn>") {
                        Some((content, _)) => {
                            messages
                                .push(Message {
                                    role: role.to_string(),
                                    content: content.trim_end_matches('\n').to_string(),
                                })
                        }
                        None => return Err(LLMError::ValidationError),
                    }
                }
                None => return Err(LLMError::ValidationError),
            }
        }
        Ok(messages)
    }
    pub fn marketing_parse_conv(conv: Vec<Message>) -> String {
        conv.into_iter()
            .map(|x| ::alloc::__export::must_use({
                let res = ::alloc::fmt::format(
                    format_args!("[{0}]:{1}", x.role.to_uppercase(), x.content),
                );
                res
            }))
            .collect::<Vec<_>>()
            .join("\n")
    }
}
