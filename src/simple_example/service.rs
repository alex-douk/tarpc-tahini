use std::collections::HashMap;

use alohomora::bbox::BBox as PCon;
use alohomora::pure::PrivacyPureRegion;
// use alohomora::tarpc::client::{TahiniChannel, TahiniNewClient, TahiniRequestDispatch, TahiniStub};
use alohomora::tarpc::client::{
    TahiniChannel, TahiniNewClient, TahiniRequestDispatch, TahiniStub, TahiniTransport,
};
// use alohomora::tarpc::enums::{DeboxedTahiniEnum, TahiniEnum, TahiniEnum2};
// use alohomora::tarpc::server::TahiniServe;
use alohomora::tarpc::server::TahiniServe;
// use alohomora::tarpc::traits::{NamedTahiniType, TahiniType, TahiniType2};
use alohomora::tarpc::{
    enums::{TahiniEnum, TahiniVariantsEnum},
    traits::{TahiniError, TahiniType},
};
use alohomora::AlohomoraType;
use serde::{Deserialize, Serialize};
use tarpc::client::{Config, RpcError};
use tarpc::server::Serve;
use tarpc::{ClientMessage, Response, Transport};

// use alohomora::tarpc::hacky::ExamplePolicy;
use crate::policy::ExamplePolicy;
//
#[derive(Debug, Deserialize, Clone)]
pub struct InnerStruct {
    pub a: u16,
}

impl TahiniType for InnerStruct {
    fn to_tahini_enum(&self) -> TahiniEnum {
        let mut map = HashMap::new();
        map.insert("a", TahiniEnum::Value(Box::new(self.a)));
        TahiniEnum::Struct("InnerStruct", map)
    }
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct MyError {}

impl std::fmt::Display for MyError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Generic error")
    }
}

impl std::error::Error for MyError {}

impl TahiniError for MyError {}

#[derive(Debug, Deserialize, Clone)]
pub struct MyType {
    pub a: i32,
    pub b: PCon<String, ExamplePolicy>,
    pub c: Result<i32, MyError>,
}

impl TahiniType for MyType {
    fn to_tahini_enum(&self) -> TahiniEnum {
        let mut map = HashMap::new();
        map.insert("a", self.a.to_tahini_enum());
        map.insert("b", self.b.to_tahini_enum());
        map.insert("c", self.c.to_tahini_enum());
        TahiniEnum::Struct("MyType", map)
    }
}

// START: this part is what the developer writes.
// #[TahiniService]
pub trait SimpleService: Sized + Clone {
    async fn increment(
        self,
        ctxt: tarpc::context::Context,
        x: PCon<i32, ExamplePolicy>,
    ) -> PCon<String, ExamplePolicy>;

    // Autogenerated by macro
    fn serve(self) -> SimpleServiceServe<Self> {
        println!("Invoking Service::serve");
        SimpleServiceServe(self)
    }

    async fn test_types(self, ctxt: tarpc::context::Context, x: MyType) -> MyType;
}

#[derive(Clone)]
pub struct SimpleServiceServer;
impl SimpleService for SimpleServiceServer {
    async fn increment(
        self,
        _context: tarpc::context::Context,
        x: PCon<i32, ExamplePolicy>,
    ) -> PCon<String, ExamplePolicy> {
        println!("Within the application level, we are operating on PCons.");
        x.into_ppr(PrivacyPureRegion::new(|val| format!("{}", val + 1)))
    }
    async fn test_types(self, ctxt: tarpc::context::Context, mut x: MyType) -> MyType {
        x.a = 0;
        x
    }
}
// END: the part that developers write is over.

// #[derive(TahiniType)]
#[derive(Deserialize, Clone)]
pub enum SimpleServiceRequest {
    Increment(PCon<i32, ExamplePolicy>),
    TestType(MyType),
}

// #[derive(TahiniType)]
#[derive(Deserialize)]
pub enum SimpleServiceResponse {
    Increment(PCon<String, ExamplePolicy>),
    TestType(MyType),
}

// Server-side generated code.
#[derive(Clone, Copy)]
pub struct SimpleServiceServe<S: SimpleService + Clone>(pub S);

impl<S: SimpleService + Clone> TahiniServe for SimpleServiceServe<S> {
    type Req = SimpleServiceRequest;
    type Resp = SimpleServiceResponse;
    async fn serve(
        self,
        ctx: tarpc::context::Context,
        req: Self::Req,
    ) -> Result<Self::Resp, tarpc::ServerError> {
        match req {
            SimpleServiceRequest::Increment(v) => {
                println!("Invoking serve::increment");
                let resp = self.0.increment(ctx, v).await;
                Ok(SimpleServiceResponse::Increment(resp))
            }
            SimpleServiceRequest::TestType(test) => {
                println!("Invoking serve::test_types");
                let resp = self.0.test_types(ctx, test).await;
                Ok(SimpleServiceResponse::TestType(resp))
            }
        }
    }
}

impl TahiniType for SimpleServiceRequest {
    fn to_tahini_enum(&self) -> TahiniEnum {
        match self {
            SimpleServiceRequest::Increment(bbox) => TahiniEnum::Enum(
                "SimpleServiceRequest",
                0,
                "Increment",
                TahiniVariantsEnum::NewType(Box::new(<PCon<_, _> as TahiniType>::to_tahini_enum(bbox))),
            ),
            SimpleServiceRequest::TestType(test) => TahiniEnum::Enum(
                "SimpleServiceRequest",
                1,
                "TestType",
                TahiniVariantsEnum::NewType(Box::new(test.to_tahini_enum())),
            ),
            // SimpleService2Request::Increment(bbox) => bbox.to_enum(),
        }
    }
}

impl TahiniType for SimpleServiceResponse {
    fn to_tahini_enum(&self) -> TahiniEnum {
        match self {
            SimpleServiceResponse::Increment(bbox) => TahiniEnum::Enum(
                "SimpleServiceResponse",
                0,
                "Increment",
                TahiniVariantsEnum::NewType(Box::new(<PCon<_, _> as TahiniType>::to_tahini_enum(bbox))),
            ),
            SimpleServiceResponse::TestType(test) => TahiniEnum::Enum(
                "SimpleServiceResponse",
                1,
                "TestType",
                TahiniVariantsEnum::NewType(Box::new(test.to_tahini_enum())),
            ),
        }
    }
}

pub struct SimpleServiceClient(TahiniChannel<SimpleServiceRequest, SimpleServiceResponse>);
impl SimpleServiceClient {
    pub fn new<T>(
        config: Config,
        transport: T,
    ) -> TahiniNewClient<Self, TahiniRequestDispatch<SimpleServiceRequest, SimpleServiceResponse, T>>
    where
        T: TahiniTransport<
            SimpleServiceRequest,
            SimpleServiceResponse, // ClientMessage<SimpleService2RequestIntermediate>,
        >,
    {
        let new_client = alohomora::tarpc::client::new(config, transport);
        TahiniNewClient {
            client: SimpleServiceClient(new_client.client),
            dispatch: new_client.dispatch,
        }
    }
    pub async fn increment(
        &self,
        ctx: ::tarpc::context::Context,
        x: PCon<i32, ExamplePolicy>,
    ) -> Result<PCon<String, ExamplePolicy>, RpcError> {
        let request = SimpleServiceRequest::Increment(x);
        match self.0.call(ctx, "SimpleService.increment", request).await? {
            SimpleServiceResponse::Increment(msg) => Ok(msg),
            _ => panic!("Wrong result for call increment"),
        }
    }

    pub async fn test_types(
        &self,
        ctx: ::tarpc::context::Context,
        x: MyType,
    ) -> Result<MyType, RpcError> {
        let request = SimpleServiceRequest::TestType(x);
        match self
            .0
            .call(ctx, "SimpleService2.test_types", request)
            .await?
        {
            SimpleServiceResponse::TestType(msg) => Ok(msg),
            _ => panic!("Wrong result for call test"),
        }
    }
}
