use std::collections::HashMap;

use alohomora::bbox::BBox as PCon;
use alohomora::pure::PrivacyPureRegion;
// use alohomora::tarpc::client::{TahiniChannel, TahiniNewClient, TahiniRequestDispatch, TahiniStub};
use alohomora::tarpc::client::{
    TahiniChannel, TahiniNewClient, TahiniRequestDispatch, TahiniStub, TahiniTransport,
};
// use alohomora::tarpc::enums::{DeboxedTahiniEnum, TahiniEnum, TahiniEnum2};
// use alohomora::tarpc::server::TahiniServe;
use alohomora::tarpc::server::TahiniServe;
// use alohomora::tarpc::traits::{NamedTahiniType, TahiniType, TahiniType2};
use alohomora::tarpc::{
    traits::TahiniType,
    enums::TahiniEnum
};
use alohomora::AlohomoraType;
use serde::{Deserialize, Serialize};
use tarpc::client::{Config, RpcError};
use tarpc::server::Serve;
use tarpc::{ClientMessage, Response, Transport};

// use alohomora::tarpc::hacky::ExamplePolicy;
use crate::policy::ExamplePolicy;
//
#[derive(Debug, Deserialize, Clone)]
pub struct InnerStruct{
    pub a: u16
}

impl TahiniType for InnerStruct {
    fn to_enum(&self) -> TahiniEnum {
        let mut map = HashMap::new();
        map.insert("a", TahiniEnum::Value(Box::new(self.a)));
        TahiniEnum::Struct("InnerStruct", map)
    }
}

#[derive(Debug, Deserialize, Clone)]
pub struct MyType{
    pub a: i32,
    pub b: PCon<String, ExamplePolicy>,
    pub c: InnerStruct
}

impl TahiniType for MyType {
    fn to_enum(&self) -> TahiniEnum {
        let mut map = HashMap::new();
        map.insert("a", TahiniEnum::Value(Box::new(self.a)));
        map.insert("b", <PCon<_, _> as TahiniType>::to_enum(&self.b));
        map.insert("c", self.c.to_enum());
        TahiniEnum::Struct("MyType", map)
    }
}

// START: this part is what the developer writes.
// #[TahiniService]
pub trait SimpleService: Sized + Clone {
    async fn increment(
        self,
        ctxt: tarpc::context::Context,
        x: PCon<i32, ExamplePolicy>,
    ) -> PCon<String, ExamplePolicy>;

    // Autogenerated by macro
    fn serve(self) -> SimpleServiceServe<Self> {
        println!("Invoking Service::serve");
        SimpleServiceServe(self)
    }

    async fn test_types(
        self,
        ctxt: tarpc::context::Context,
        x: MyType
    ) -> MyType;
}

#[derive(Clone)]
pub struct SimpleServiceServer;
impl SimpleService for SimpleServiceServer {
    async fn increment(
        self,
        _context: tarpc::context::Context,
        x: PCon<i32, ExamplePolicy>,
    ) -> PCon<String, ExamplePolicy> {
        println!("Within the application level, we are operating on PCons.");
        x.into_ppr(PrivacyPureRegion::new(|val| format!("{}", val + 1)))
    }
    async fn test_types(
            self,
            ctxt: tarpc::context::Context,
            mut x: MyType
        ) -> MyType {
        x.a = 0;
        x
    }
}
// END: the part that developers write is over.

// #[derive(TahiniType)]
#[derive(Deserialize, Clone)]
pub enum SimpleServiceRequest {
    Increment(PCon<i32, ExamplePolicy>),
    TestType(MyType)
}

// #[derive(TahiniType)]
#[derive(Deserialize)]
pub enum SimpleServiceResponse {
    Increment(PCon<String, ExamplePolicy>),
    TestType(MyType)
}

// Server-side generated code.
#[derive(Clone, Copy)]
pub struct SimpleServiceServe<S: SimpleService + Clone>(pub S);

impl<S: SimpleService + Clone> TahiniServe for SimpleServiceServe<S> {
    type Req = SimpleServiceRequest;
    type Resp = SimpleServiceResponse;
    async fn serve(
        self,
        ctx: tarpc::context::Context,
        req: Self::Req,
    ) -> Result<Self::Resp, tarpc::ServerError> {
        match req {
            SimpleServiceRequest::Increment(v) => {
                println!("Invoking serve::increment");
                let resp = self.0.increment(ctx, v).await;
                Ok(SimpleServiceResponse::Increment(resp))
            }
            SimpleServiceRequest::TestType(test) => {
                println!("Invoking serve::test_types");
                let resp = self.0.test_types(ctx, test).await;
                Ok(SimpleServiceResponse::TestType(resp))
            }
        }
    }
}

impl TahiniType for SimpleServiceRequest {
    fn to_enum(&self) -> TahiniEnum {
        match self {
            SimpleServiceRequest::Increment(bbox) => TahiniEnum::EnumNewType(
                "SimpleServiceRequest", 0, "Increment", Box::new(<PCon<_, _> as TahiniType>::to_enum(bbox))
                ),
            SimpleServiceRequest::TestType(test) => TahiniEnum::EnumNewType(
                "SimpleServiceRequest", 1, "TestType", Box::new(test.to_enum())
                ),
            // SimpleService2Request::Increment(bbox) => bbox.to_enum(),
        }
    }
}

impl TahiniType for SimpleServiceResponse {
    fn to_enum(&self) -> TahiniEnum {
        match self {
            SimpleServiceResponse::Increment(bbox) => TahiniEnum::EnumNewType(
                "SimpleServiceResponse", 0, "Increment", Box::new(<PCon<_, _> as TahiniType>::to_enum(bbox))),
            SimpleServiceResponse::TestType(test) => TahiniEnum::EnumNewType(
                "SimpleServiceResponse", 1, "TestType", Box::new(test.to_enum())
                ),
        }
    }
}

pub struct SimpleServiceClient(TahiniChannel<SimpleServiceRequest, SimpleServiceResponse>);
impl SimpleServiceClient {
    pub fn new<T>(
        config: Config,
        transport: T,
    ) -> TahiniNewClient<
        Self,
        TahiniRequestDispatch<SimpleServiceRequest, SimpleServiceResponse, T>,
    >
    where
        T: TahiniTransport<
            SimpleServiceRequest,
            SimpleServiceResponse, // ClientMessage<SimpleService2RequestIntermediate>,
                                    // Response<SimpleService2ResponseIntermediate>,
        >,
    {
        let new_client = alohomora::tarpc::client::new(config, transport);
        TahiniNewClient {
            client: SimpleServiceClient(new_client.client),
            dispatch: new_client.dispatch,
        }
    }
    pub async fn increment(
        &self,
        ctx: ::tarpc::context::Context,
        x: PCon<i32, ExamplePolicy>,
    ) -> Result<PCon<String, ExamplePolicy>, RpcError> {
        let request = SimpleServiceRequest::Increment(x);
        match self
            .0
            .call(ctx, "SimpleService.increment", request)
            .await?
        {
            SimpleServiceResponse::Increment(msg) => Ok(msg),
            _ => panic!("Wrong result for call increment")
        }
    }

    pub async fn test_types(
        &self,
        ctx: ::tarpc::context::Context,
        x: MyType
    ) -> Result<MyType, RpcError> {
        let request = SimpleServiceRequest::TestType(x);
        match self
            .0
            .call(ctx, "SimpleService2.test_types", request)
            .await?
        {
            SimpleServiceResponse::TestType(msg) => Ok(msg),
            _ => panic!("Wrong result for call test")
        }
    }
}
